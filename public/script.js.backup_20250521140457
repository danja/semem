// Global error handler
window.addEventListener('error', function (event) {
    console.error('Global error caught:', event.error || event.message);
    // Always hide loading indicator if there's an error
    let loadingElement = document.getElementById('loading-indicator');
    if (loadingElement) {
        loadingElement.style.display = 'none';
        console.error('Loading indicator hidden due to global error');
    }
});

document.addEventListener('DOMContentLoaded', () => {
    console.log('Initializing Semem API Interface');

    // Debug message display
    window.showDebug = function (message) {
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            console.log(`[DEBUG] ${message}`);
        }
    };

    // Get reference to loading indicator (used throughout the script)
    const loadingIndicator = document.getElementById('loading-indicator');
    if (loadingIndicator) {
        // Force it to be hidden at startup
        loadingIndicator.style.display = 'none';
        window.showDebug('Loading indicator hidden at initialization');
    }

    window.showDebug('Application initialized');

    // API configuration
    const apiConfig = {
        baseUrl: '' // Empty string means same origin (default)
        // For specific servers, use absolute URL, e.g.: 'http://localhost:3000'
    };

    // Check if running on a different port than the API server
    // The UI server runs on port 4100, search API endpoints are available on the same port
    const currentPort = window.location.port;

    // No need to explicitly set the API URL since we're making requests to the same server
    // Log the port we're running on for debugging
    console.log(`Running on port: ${currentPort}`);

    window.showDebug(`Running on port: ${currentPort}`);
    window.showDebug(`Using same origin for API requests`);

    console.log('API Config:', apiConfig);

    // Store conversation state
    const state = {
        conversationId: null,
        chatHistory: [],
        streamingChatHistory: []
    };

    // Cache DOM elements for tabs
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    const innerTabButtons = document.querySelectorAll('.tab-inner-btn');
    const innerTabContents = document.querySelectorAll('.inner-tab-content');
    // Note: loadingIndicator is already defined above
    const apiStatus = document.getElementById('api-status');
    const statusIndicator = document.querySelector('.status-indicator');
    const statusText = document.querySelector('.status-text');

    // Initialize tab navigation
    initTabs();

    // Initialize range inputs with value display
    initRangeInputs();

    // Initialize API endpoint forms
    initSearchForm();
    initMemoryForms();
    
    // Initialize chat forms and load providers
    initChatForms().then(() => {
        loadChatProviders();
    });
    
    initEmbeddingForm();
    initConceptsForm();
    initIndexForm();

    // Failsafe mechanism to ensure loading indicator doesn't get stuck
    let loadingTimeout = null;
    const resetLoadingTimeout = () => {
        if (loadingTimeout) {
            clearTimeout(loadingTimeout);
        }
        // If loading indicator is visible for more than 10 seconds, force hide it
        loadingTimeout = setTimeout(() => {
            if (loadingIndicator && loadingIndicator.style.display !== 'none') {
                window.showDebug('FAILSAFE: Loading indicator visible for too long, forcing hide');
                loadingIndicator.style.display = 'none';
            }
        }, 10000);
    };

    // Check API health
    window.showDebug('Checking API health...');
    resetLoadingTimeout();
    checkAPIHealth();

    // Log the API URL
    console.log('API URLs will use base:', apiConfig.baseUrl || 'same origin');

    /**
     * Initialize tab navigation
     */
    function initTabs() {
        console.log('Initializing tab navigation');

        // Main tabs
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');

                // Update button states
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // Update content visibility
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });

        // Inner tabs
        innerTabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const parentTab = button.closest('.tab-content');
                const innerTabId = button.getAttribute('data-inner-tab');

                // Update button states within this parent tab
                parentTab.querySelectorAll('.tab-inner-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                button.classList.add('active');

                // Update content visibility within this parent tab
                parentTab.querySelectorAll('.inner-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(innerTabId).classList.add('active');
            });
        });
    }

    /**
     * Initialize range inputs to show current value
     */
    function initRangeInputs() {
        const rangeInputs = document.querySelectorAll('input[type="range"]');

        rangeInputs.forEach(input => {
            const valueDisplay = document.getElementById(`${input.id}-value`) ||
                input.nextElementSibling;

            if (valueDisplay) {
                // Set initial value
                valueDisplay.textContent = input.value;

                // Update on change
                input.addEventListener('input', () => {
                    valueDisplay.textContent = input.value;
                });
            }
        });
    }

    /**
     * Initialize search form
     */
    function initSearchForm() {
        window.showDebug('Initializing search form');

        const searchForm = document.getElementById('search-form');
        const searchResults = document.getElementById('search-results');

        searchForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(searchForm);
            const query = formData.get('query');
            const limit = formData.get('limit');
            const threshold = formData.get('threshold');
            const types = formData.get('types');

            if (!query) return;

            try {
                showLoading(true);
                window.showDebug('Search form submitted, showing loading indicator');

                // Clear previous results first
                searchResults.innerHTML = `
                    <div class="results-placeholder">
                        <p>Searching for "${escapeHtml(query)}"...</p>
                    </div>
                `;

                // Build query params
                const params = new URLSearchParams({
                    q: query,  // Server expects 'q' parameter, not 'query'
                    limit: limit
                });

                if (threshold) params.append('threshold', threshold);
                if (types) params.append('types', types);

                window.showDebug(`Searching with params: ${params.toString()}`);

                // Perform search with longer timeout for search operations
                const searchUrl = `${apiConfig.baseUrl}/api/search?${params.toString()}`;
                window.showDebug(`Making search request to: ${searchUrl}`);

                try {
                    const response = await fetchWithTimeout(searchUrl, {
                        timeout: 30000 // 30 second timeout for search
                    });

                    window.showDebug(`Search response received: ${response.status}`);

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'Search failed');
                    }

                    const data = await response.json();
                    window.showDebug(`Search returned ${data.results?.length || 0} results`);
                    displaySearchResults(data.results || [], searchResults);

                } catch (fetchError) {
                    window.showDebug(`Search fetch error: ${fetchError.message}`);

                    // Special handling for timeouts
                    if (fetchError.name === 'AbortError') {
                        displayError('Search request timed out. This may happen if the server is busy or the search operation is complex. Please try again with a simpler query.', searchResults);
                    } else {
                        displayError(fetchError.message || 'Search operation failed', searchResults);
                    }
                }

            } catch (error) {
                window.showDebug(`General search error: ${error.message}`);
                displayError(`Search error: ${error.message}`, searchResults);
            } finally {
                showLoading(false);
                window.showDebug('Search completed, hiding loading indicator');
            }
        });
    }

    /**
     * Initialize memory forms
     */
    function initMemoryForms() {
        console.log('Initializing memory forms');

        // Memory Store Form
        const memoryStoreForm = document.getElementById('memory-store-form');
        const memoryStoreResult = document.getElementById('memory-store-result');

        memoryStoreForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                showLoading(true);

                const formData = new FormData(memoryStoreForm);
                const payload = {
                    prompt: formData.get('prompt'),
                    response: formData.get('response')
                };

                // Parse metadata if provided
                const metadataStr = formData.get('metadata');
                if (metadataStr) {
                    try {
                        payload.metadata = JSON.parse(metadataStr);
                    } catch (err) {
                        throw new Error('Invalid metadata JSON format');
                    }
                }

                console.log('Storing memory:', payload);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/memory`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to store memory');
                }

                const data = await response.json();
                displayMemoryStoreResult(data, memoryStoreResult);

            } catch (error) {
                console.error('Memory store error:', error);
                displayError(error.message, memoryStoreResult);
            } finally {
                showLoading(false);
            }
        });

        // Memory Search Form
        const memorySearchForm = document.getElementById('memory-search-form');
        const memorySearchResults = document.getElementById('memory-search-results');

        memorySearchForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                showLoading(true);

                const formData = new FormData(memorySearchForm);
                const query = formData.get('query');
                const limit = formData.get('limit');
                const threshold = formData.get('threshold');

                if (!query) return;

                // Build query params
                const params = new URLSearchParams({
                    query: query,
                    limit: limit
                });

                if (threshold) params.append('threshold', threshold);

                console.log(`Searching memory with params: ${params.toString()}`);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/memory/search?${params.toString()}`);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Memory search failed');
                }

                const data = await response.json();
                displayMemorySearchResults(data.results, memorySearchResults);

            } catch (error) {
                console.error('Memory search error:', error);
                displayError(error.message, memorySearchResults);
            } finally {
                showLoading(false);
            }
        });
    }

    /**
     * Load available chat providers
     */
    async function loadChatProviders() {
        try {
            const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/providers`);
            if (!response.ok) {
                throw new Error('Failed to load providers');
            }
            
            const data = await response.json();
            const providers = data.providers || [];
            
            // Update both provider dropdowns
            const providerSelects = document.querySelectorAll('.provider-select');
            providerSelects.forEach(select => {
                // Clear loading message
                select.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.disabled = true;
                defaultOption.selected = true;
                defaultOption.textContent = 'Select a provider';
                select.appendChild(defaultOption);
                
                // Add provider options
                providers.forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider.id;
                    option.textContent = `${provider.name} (${provider.model})`;
                    select.appendChild(option);
                });
                
                // Select first provider by default if available
                if (providers.length > 0) {
                    select.value = providers[0].id;
                }
            });
            
            console.log('Loaded chat providers:', providers);
        } catch (error) {
            console.error('Error loading providers:', error);
            // Update UI to show error
            const providerSelects = document.querySelectorAll('.provider-select');
            providerSelects.forEach(select => {
                select.innerHTML = '';
                const errorOption = document.createElement('option');
                errorOption.disabled = true;
                errorOption.selected = true;
                errorOption.textContent = 'Failed to load providers';
                select.appendChild(errorOption);
            });
        }
    }

    /**
     * Initialize chat forms
     */
    async function initChatForms() {
        console.log('Initializing chat forms');

        // Standard Chat Form
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');

        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(chatForm);
            const prompt = formData.get('prompt');
            const temperature = formData.get('temperature');
            const useMemory = formData.has('useMemory');

            if (!prompt) return;

            try {
                // Add user message to UI
                addChatMessage(prompt, 'user', chatMessages);
                chatInput.value = '';

                showLoading(true);

                // Create request payload
                const payload = {
                    prompt,
                    temperature: parseFloat(temperature),
                    useMemory,
                    conversationId: state.conversationId
                };

                console.log('Sending chat message:', payload);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Chat request failed');
                }

                const data = await response.json();

                // Store conversation ID for future messages
                if (data.conversationId) {
                    state.conversationId = data.conversationId;
                }

                // Add assistant message to UI
                addChatMessage(data.response, 'assistant', chatMessages);

            } catch (error) {
                console.error('Chat error:', error);
                addChatMessage(`Error: ${error.message}`, 'error', chatMessages);
            } finally {
                showLoading(false);
            }
        });

        // Streaming Chat Form
        const chatStreamForm = document.getElementById('chat-stream-form');
        const chatStreamInput = document.getElementById('chat-stream-input');
        const chatStreamMessages = document.getElementById('chat-stream-messages');

        chatStreamForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(chatStreamForm);
            const prompt = formData.get('prompt');
            const temperature = formData.get('temperature');
            const useMemory = formData.has('useMemory');

            if (!prompt) return;

            try {
                // Add user message to UI
                addChatMessage(prompt, 'user', chatStreamMessages);
                chatStreamInput.value = '';

                // Create message container for streaming response
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message assistant';
                messageElement.textContent = ''; // Will be filled by stream
                chatStreamMessages.appendChild(messageElement);
                chatStreamMessages.scrollTop = chatStreamMessages.scrollHeight;

                // Create request payload
                const payload = {
                    prompt,
                    temperature: parseFloat(temperature),
                    useMemory,
                    conversationId: state.conversationId
                };

                console.log('Sending streaming chat message:', payload);

                // Make streaming request
                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/chat/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Chat stream request failed');
                }

                // Process the event stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();

                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete events in buffer
                    const events = buffer.split('\n\n');
                    buffer = events.pop() || ''; // Keep the last incomplete event in the buffer

                    for (const event of events) {
                        if (event.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(event.substring(6));

                                if (data.done) {
                                    // Stream completed
                                    console.log('Stream completed');
                                } else if (data.chunk) {
                                    // Append chunk to message
                                    messageElement.textContent += data.chunk;
                                    chatStreamMessages.scrollTop = chatStreamMessages.scrollHeight;
                                }
                            } catch (e) {
                                console.warn('Error parsing stream data:', e);
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Chat stream error:', error);
                addChatMessage(`Error: ${error.message}`, 'error', chatStreamMessages);
            }
        });
    }

    /**
     * Initialize embedding form
     */
    function initEmbeddingForm() {
        console.log('Initializing embedding form');

        const embeddingForm = document.getElementById('embedding-form');
        const embeddingResult = document.getElementById('embedding-result');
        const embeddingPreview = document.getElementById('embedding-preview');
        const embeddingDimensions = document.getElementById('embedding-dimensions');
        const embeddingModelName = document.getElementById('embedding-model-name');
        const copyEmbeddingBtn = document.getElementById('copy-embedding');

        let fullEmbedding = [];

        embeddingForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                showLoading(true);

                const formData = new FormData(embeddingForm);
                const payload = {
                    text: formData.get('text')
                };

                const model = formData.get('model');
                if (model) payload.model = model;

                console.log('Generating embedding:', payload);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/memory/embedding`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to generate embedding');
                }

                const data = await response.json();
                displayEmbeddingResult(data);

            } catch (error) {
                console.error('Embedding error:', error);
                displayError(error.message, embeddingResult);
            } finally {
                showLoading(false);
            }
        });

        function displayEmbeddingResult(data) {
            // Store full embedding
            fullEmbedding = data.embedding;

            // Update stats
            embeddingDimensions.textContent = data.dimension || fullEmbedding.length;
            embeddingModelName.textContent = data.model || 'default';

            // Show preview (first 10 values)
            const preview = fullEmbedding.slice(0, 10);
            embeddingPreview.textContent = JSON.stringify(preview, null, 2);

            // Show result
            embeddingResult.classList.remove('hidden');
        }

        // Copy embedding button
        copyEmbeddingBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(JSON.stringify(fullEmbedding))
                .then(() => {
                    copyEmbeddingBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyEmbeddingBtn.textContent = 'Copy Full Vector';
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy:', err);
                });
        });
    }

    /**
     * Initialize concepts form
     */
    function initConceptsForm() {
        console.log('Initializing concepts form');

        const conceptsForm = document.getElementById('concepts-form');
        const conceptsResult = document.getElementById('concepts-result');
        const conceptsList = document.getElementById('concepts-list');

        conceptsForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                showLoading(true);

                const formData = new FormData(conceptsForm);
                const payload = {
                    text: formData.get('text')
                };

                console.log('Extracting concepts:', payload);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/memory/concepts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to extract concepts');
                }

                const data = await response.json();
                displayConceptsResult(data);

            } catch (error) {
                console.error('Concepts error:', error);
                displayError(error.message, conceptsResult);
            } finally {
                showLoading(false);
            }
        });

        function displayConceptsResult(data) {
            // Clear previous results
            conceptsList.innerHTML = '';

            // Add concept tags
            if (data.concepts && data.concepts.length > 0) {
                data.concepts.forEach(concept => {
                    const conceptTag = document.createElement('div');
                    conceptTag.className = 'concept-tag';
                    conceptTag.textContent = concept;
                    conceptsList.appendChild(conceptTag);
                });
            } else {
                conceptsList.innerHTML = '<p>No concepts extracted</p>';
            }

            // Show result
            conceptsResult.classList.remove('hidden');
        }
    }

    /**
     * Initialize index form
     */
    function initIndexForm() {
        console.log('Initializing index form');

        const indexForm = document.getElementById('index-form');
        const indexResult = document.getElementById('index-result');

        indexForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                showLoading(true);

                const formData = new FormData(indexForm);
                const payload = {
                    content: formData.get('content'),
                    type: formData.get('type')
                };

                const title = formData.get('title');
                if (title) payload.title = title;

                // Parse metadata if provided
                const metadataStr = formData.get('metadata');
                if (metadataStr) {
                    try {
                        payload.metadata = JSON.parse(metadataStr);
                    } catch (err) {
                        throw new Error('Invalid metadata JSON format');
                    }
                }

                console.log('Indexing content:', payload);

                const response = await fetchWithTimeout(`${apiConfig.baseUrl}/api/index`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to index content');
                }

                const data = await response.json();
                displayIndexResult(data);

            } catch (error) {
                console.error('Index error:', error);
                displayError(error.message, indexResult);
            } finally {
                showLoading(false);
            }
        });

        function displayIndexResult(data) {
            // Create result HTML
            indexResult.innerHTML = `
                <h3>Content Indexed</h3>
                <p>The content was successfully indexed with ID: <strong>${data.id}</strong></p>
            `;

            // Show result
            indexResult.classList.remove('hidden');
        }
    }

    /**
     * Check API health
     */
    async function checkAPIHealth() {
        try {
            window.showDebug('Starting API health check');
            statusIndicator.className = 'status-indicator';
            statusText.textContent = 'Checking API...';

            const healthUrl = `${apiConfig.baseUrl}/api/health`;
            window.showDebug(`Checking API health at: ${healthUrl}`);

            showLoading(true); // Show loading while checking
            window.showDebug('Loading indicator shown during health check');

            const response = await fetchWithTimeout(healthUrl, { timeout: 5000 });
            window.showDebug(`Health check response: ${response.status}`);

            // Always hide loading indicator after health check
            showLoading(false);
            window.showDebug('Loading indicator hidden after health check');

            if (response.ok) {
                const data = await response.json();
                window.showDebug(`Health check data: ${JSON.stringify(data).substring(0, 100)}...`);

                if (data.status === 'healthy') {
                    statusIndicator.classList.add('connected');
                    statusText.textContent = 'API Connected';
                    window.showDebug('API health check successful - API is healthy');
                } else {
                    statusIndicator.classList.add('disconnected');
                    statusText.textContent = 'API Degraded';
                    window.showDebug('API health check returned degraded status');
                }

                // Force the loading indicator to hide again just to be sure
                document.getElementById('loading-indicator').style.display = 'none';
                window.showDebug('Forced loading indicator to hide with inline style');

            } else {
                throw new Error(`Health check failed with status: ${response.status}`);
            }
        } catch (error) {
            console.error('API health check error:', error);
            window.showDebug(`Health check error: ${error.message}`);

            // Always hide loading indicator after health check
            showLoading(false);
            window.showDebug('Loading indicator hidden after health check error');

            // Force the loading indicator to hide again just to be sure
            document.getElementById('loading-indicator').style.display = 'none';
            window.showDebug('Forced loading indicator to hide with inline style');

            statusIndicator.classList.add('disconnected');

            // Provide more helpful error message based on error type
            if (error.name === 'AbortError') {
                statusText.textContent = 'API Timeout';
                window.showDebug('Connection timed out. The API server might be overloaded or not running.');
            } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                statusText.textContent = 'API Unreachable';
                window.showDebug(`Network error connecting to ${apiConfig.baseUrl || window.location.origin}`);

                // If we're not explicitly setting baseUrl, suggest checking the server port
                if (!apiConfig.baseUrl) {
                    window.showDebug('API connection failed. Make sure the server is running on port 3000.');
                }
            } else {
                statusText.textContent = 'API Unavailable';
            }

            // Add a retry button if health check fails
            const apiStatus = document.getElementById('api-status');
            if (!document.getElementById('retry-health-check')) {
                const retryButton = document.createElement('button');
                retryButton.id = 'retry-health-check';
                retryButton.className = 'btn btn-sm';
                retryButton.textContent = 'Retry';
                retryButton.addEventListener('click', () => {
                    // Remove self
                    retryButton.remove();
                    // Check health again
                    window.showDebug('Retry button clicked, trying health check again');
                    checkAPIHealth();
                });
                apiStatus.appendChild(retryButton);
                window.showDebug('Added retry button for health check');
            }
        }
    }

    /**
     * Display search results
     */
    function displaySearchResults(results, container) {
        // Clear previous results
        container.innerHTML = '';

        if (!results || results.length === 0) {
            container.innerHTML = `
                <div class="results-placeholder">
                    <p>No results found. Try a different search query.</p>
                </div>
            `;
            return;
        }

        // Create result elements
        results.forEach(result => {
            const resultElement = document.createElement('div');
            resultElement.className = 'result-item';

            // Calculate similarity percentage
            const similarityPercent = Math.min(100, Math.max(0, Math.round((result.score || 0) * 100)));

            resultElement.innerHTML = `
                <h3 class="result-title">
                    ${result.title ? escapeHtml(result.title) : 'Untitled'}
                </h3>
                <p class="result-content">${escapeHtml(result.content || 'No content')}</p>
                <div class="result-meta">
                    <span class="result-type">${escapeHtml(result.type || 'unknown')}</span>
                    <span class="result-score">Similarity: ${similarityPercent}%</span>
                </div>
            `;

            container.appendChild(resultElement);
        });
    }

    /**
     * Display memory store result
     */
    function displayMemoryStoreResult(data, container) {
        container.innerHTML = `
            <h3>Memory Stored</h3>
            <p>Memory was successfully stored with ID: <strong>${data.id}</strong></p>
            ${data.concepts ?
                `<p>Extracted concepts: ${data.concepts.map(c => escapeHtml(c)).join(', ')}</p>` :
                ''}
        `;

        container.classList.remove('hidden');
    }

    /**
     * Display memory search results
     */
    function displayMemorySearchResults(results, container) {
        // Clear previous results
        container.innerHTML = '';

        if (!results || results.length === 0) {
            container.innerHTML = `
                <div class="results-placeholder">
                    <p>No memory results found. Try a different search query.</p>
                </div>
            `;
            return;
        }

        // Create result elements
        results.forEach(result => {
            const resultElement = document.createElement('div');
            resultElement.className = 'result-item';

            // Calculate similarity percentage
            const similarityPercent = Math.min(100, Math.max(0, Math.round((result.score || 0) * 100)));

            resultElement.innerHTML = `
                <h3 class="result-title">Memory ID: ${escapeHtml(result.id || 'unknown')}</h3>
                <p class="result-content"><strong>Prompt:</strong> ${escapeHtml(result.prompt || '')}</p>
                <p class="result-content"><strong>Response:</strong> ${escapeHtml(result.output || '')}</p>
                <div class="result-meta">
                    <span class="result-time">Timestamp: ${result.timestamp ? new Date(result.timestamp).toLocaleString() : 'unknown'}</span>
                    <span class="result-score">Similarity: ${similarityPercent}%</span>
                </div>
                ${result.concepts && result.concepts.length > 0 ?
                    `<div class="result-concepts">
                        <span>Concepts: ${result.concepts.map(c => escapeHtml(c)).join(', ')}</span>
                    </div>` :
                    ''}
            `;

            container.appendChild(resultElement);
        });
    }

    /**
     * Add message to chat UI
     */
    function addChatMessage(message, type, container) {
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${type}`;
        messageElement.textContent = message;
        container.appendChild(messageElement);

        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
    }

    /**
     * Display error message
     */
    function displayError(errorMessage, container) {
        if (container) {
            container.innerHTML = `
                <div class="error-message">
                    <p>Error: ${escapeHtml(errorMessage)}</p>
                </div>
            `;

            if (container.classList.contains('hidden')) {
                container.classList.remove('hidden');
            }
        }
    }

    /**
     * Show or hide loading indicator
     */
    function showLoading(show) {
        window.showDebug(`showLoading(${show}) called`);

        // Direct DOM manipulation instead of CSS classes
        if (show) {
            window.showDebug('Showing loading indicator with direct style');
            loadingIndicator.style.display = 'flex';
            loadingIndicator.classList.remove('hidden');
        } else {
            window.showDebug('Hiding loading indicator with direct style');
            loadingIndicator.style.display = 'none';
            loadingIndicator.classList.add('hidden');

            // Force a reflow to make sure the browser updates the UI
            void loadingIndicator.offsetWidth;

            // Double-check to make sure it's really hidden
            setTimeout(() => {
                if (loadingIndicator.style.display !== 'none') {
                    window.showDebug('Loading indicator still visible after timeout, forcing hide');
                    loadingIndicator.style.display = 'none';
                }
            }, 100);
        }

        window.showDebug(`Loading indicator display: ${loadingIndicator.style.display}, classes: ${loadingIndicator.className}`);
    }

    /**
     * Fetch with timeout
     */
    async function fetchWithTimeout(resource, options = {}) {
        const { timeout = 15000 } = options; // Increase default timeout to 15 seconds

        window.showDebug(`Fetching: ${resource} with timeout ${timeout}ms`);

        const controller = new AbortController();
        const id = setTimeout(() => {
            window.showDebug(`Request timed out after ${timeout}ms: ${resource}`);
            controller.abort('timeout'); // Provide a reason for the abort
        }, timeout);

        try {
            // For search requests, increase the timeout further as they can take longer
            if (resource.includes('/api/search')) {
                window.showDebug('Detected search request, increasing timeout');
                clearTimeout(id); // Clear the original timeout
                // Set a longer timeout for search requests
                setTimeout(() => {
                    window.showDebug(`Search request timed out after 30000ms: ${resource}`);
                    controller.abort('search-timeout');
                }, 30000);
            }

            const response = await fetch(resource, {
                ...options,
                signal: controller.signal
            });

            window.showDebug(`Response from ${resource}: ${response.status}`);
            clearTimeout(id);
            return response;
        } catch (error) {
            clearTimeout(id);

            // Handle AbortError specifically
            if (error.name === 'AbortError') {
                window.showDebug(`Request was aborted: ${resource}`);
                // Create a more descriptive error
                const enhancedError = new Error(`Request timed out or was aborted: ${resource}`);
                enhancedError.name = 'AbortError';
                enhancedError.originalError = error;
                throw enhancedError;
            }

            window.showDebug(`Fetch error for ${resource}: ${error.message}`);
            throw error;
        }
    }

    /**
     * Escape HTML to prevent XSS
     */
    function escapeHtml(str) {
        if (!str) return '';
        return str
            .toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
});