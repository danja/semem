<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/search/UIServer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/search/UIServer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import logger from 'loglevel';

import SearchService from './SearchService.js';
import EmbeddingService from '../embeddings/EmbeddingService.js';
import SPARQLService from '../embeddings/SPARQLService.js';
import APIRegistry from '../../api/common/APIRegistry.js';
import ChatAPI from '../../api/features/ChatAPI.js';
import MemoryManager from '../../MemoryManager.js';
import LLMHandler from '../../handlers/LLMHandler.js';
import OllamaConnector from '../../connectors/OllamaConnector.js';
import HClaudeClientConnector from '../../connectors/ClaudeConnector.js';
import MistralConnector from '../../connectors/MistralConnector.js';

/**
 * UI server application that serves the web interface and API endpoints
 */
class UIServer {
    /**
     * Creates a new UIServer
     * @param {Object} options - Configuration options
     * @param {number} options.port - The port to listen on
     * @param {string} options.graphName - The graph name to search in
     */
    constructor(options = {}) {
        this.port = options.port || 4100;
        this.graphName = options.graphName || 'http://hyperdata.it/content';
        this.chatModel = options.chatModel || 'qwen2:1.5b';
        this.embeddingModel = options.embeddingModel || 'nomic-embed-text';

        // Configure SPARQL endpoints (list of servers to try in order)
        // Support both old format (queryEndpoint/updateEndpoint) and new Config.js format (urlBase/query/update)
        this.sparqlEndpoints = this.transformEndpoints(options.sparqlEndpoints) || [
            {
                queryEndpoint: 'http://localhost:4030/semem/query',
                updateEndpoint: 'http://localhost:4030/semem/update',
                auth: {
                    user: 'admin',
                    password: 'admin123'
                }
            },
            {
                queryEndpoint: 'http://localhost:3030/semem/query',
                updateEndpoint: 'http://localhost:3030/semem/update',
                auth: {
                    user: 'admin',
                    password: 'admin'
                }
            }
        ];

        // Configure LLM provider endpoints
        this.llmProviders = options.llmProviders || [
            {
                type: 'mistral',
                apiKey: process.env.MISTRAL_API_KEY || '',
                baseUrl: process.env.MISTRAL_API_BASE || 'https://api.mistral.ai/v1',
                chatModel: process.env.MISTRAL_MODEL || 'mistral-medium',
                priority: 1
            },
            {
                type: 'claude',
                implementation: 'hyperdata', // Uses hyperdata-clients library
                apiKey: process.env.CLAUDE_API_KEY || '',
                chatModel: process.env.CLAUDE_MODEL || 'claude-3-opus-20240229',
                priority: 2
            },
            {
                type: 'ollama',
                baseUrl: 'http://localhost:11434',
                chatModel: this.chatModel,
                embeddingModel: this.embeddingModel,
                priority: 3
            },
            {
                type: 'claude',
                implementation: 'direct', // Uses direct API connection
                apiKey: process.env.CLAUDE_API_KEY || '',
                baseUrl: process.env.CLAUDE_API_BASE || 'https://api.anthropic.com',
                chatModel: process.env.CLAUDE_MODEL || 'claude-3-opus-20240229',
                priority: 4
            },
            {
                type: 'openai',
                apiKey: process.env.OPENAI_API_KEY || '',
                chatModel: 'gpt-3.5-turbo',
                embeddingModel: 'text-embedding-3-small',
                priority: 5
            }
        ];

        // Separate default providers for chat and embedding
        this.defaultChatProvider = this.llmProviders.find(p => p.type === 'mistral') ||
            this.llmProviders.find(p => p.type === 'claude' &amp;&amp; p.implementation === 'direct') ||
            this.llmProviders.find(p => p.type === 'claude' &amp;&amp; p.implementation === 'hyperdata') ||
            this.llmProviders.find(p => p.type === 'ollama') ||
            this.llmProviders[0];

        this.defaultEmbeddingProvider = this.llmProviders.find(p => p.type === 'ollama') ||
            this.llmProviders.find(p => p.type === 'openai') ||
            this.llmProviders[0];

        // Initialize services
        this.embeddingService = new EmbeddingService();

        // Initialize SPARQL service with first endpoint, others will be tried if this fails
        this.sparqlService = new SPARQLService({
            queryEndpoint: this.sparqlEndpoints[0].queryEndpoint,
            updateEndpoint: this.sparqlEndpoints[0].updateEndpoint,
            graphName: this.graphName,
            auth: this.sparqlEndpoints[0].auth
        });

        this.searchService = new SearchService({
            embeddingService: this.embeddingService,
            sparqlService: this.sparqlService,
            graphName: this.graphName
        });

        // Initialize API registry
        this.apiRegistry = new APIRegistry();

        // Create Express app
        this.app = express();

        // Get directory name for ES modules
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);

        // Calculate paths for project root and public directory
        this.projectRoot = path.resolve(__dirname, '..', '..', '..');
        this.publicDir = path.join(this.projectRoot, 'dist');

        logger.info(`UIServer initialized with port: ${this.port}, graph: ${this.graphName}`);
    }

    /**
     * Configure the Express app
     */
    configureApp() {
        // Middleware
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));

        // Add timing middleware for performance tracking
        this.app.use((req, res, next) => {
            req.startTime = Date.now();
            next();
        });

        // Serve webpack dist files with /dist path
        this.app.use('/dist', express.static(this.publicDir));

        // Also serve from root for main page
        this.app.use(express.static(this.publicDir));

        // Serve node_modules for Atuin CSS and other dependencies
        this.app.use('/node_modules', express.static(path.join(this.projectRoot, 'node_modules')));

        // API endpoint for searching
        this.app.get('/api/search', this.handleSearch.bind(this));

        // Add health check endpoint
        this.app.get('/api/health', this.handleHealthCheck.bind(this));

        // Chat endpoints
        this.app.post('/api/chat', this.handleChat.bind(this));
        this.app.post('/api/chat/stream', this.handleChatStream.bind(this));
        this.app.post('/api/chat/completion', this.handleChatCompletion.bind(this));

        // Memory endpoints
        this.app.post('/api/memory', this.handleMemoryStore.bind(this));
        this.app.get('/api/memory/search', this.handleMemorySearch.bind(this));
        this.app.post('/api/memory/embedding', this.handleEmbedding.bind(this));
        this.app.post('/api/memory/concepts', this.handleConcepts.bind(this));

        // Memory visualization endpoints
        this.app.post('/api/memory/graph', this.handleMemoryGraph.bind(this));
        this.app.post('/api/memory/timeline', this.handleMemoryTimeline.bind(this));
        this.app.post('/api/memory/clusters', this.handleMemoryClusters.bind(this));
        this.app.post('/api/memory/search/advanced', this.handleAdvancedMemorySearch.bind(this));

        // Provider endpoints
        this.app.get('/api/providers', this.handleListProviders.bind(this));

        // SPARQL Browser endpoints
        this.app.get('/api/sparql/endpoints', this.handleSparqlEndpoints.bind(this));
        this.app.post('/api/sparql/query', this.handleSparqlQuery.bind(this));
        this.app.post('/api/sparql/construct', this.handleSparqlConstruct.bind(this));
        this.app.post('/api/sparql/validate', this.handleSparqlValidate.bind(this));
        this.app.post('/api/sparql/insert', this.handleSparqlInsert.bind(this));
        this.app.post('/api/sparql/test', this.handleSparqlTest.bind(this));

        // HTML route for the UI
        this.app.get('/', (req, res) => {
            res.sendFile(path.join(this.publicDir, 'index.html'));
        });
    }

    /**
     * Handle search API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSearch(req, res) {
        try {
            const query = req.query.q || '';
            const limit = parseInt(req.query.limit) || 5;

            logger.info(`Search request for: "${query}" with limit: ${limit}`);

            if (!query.trim()) {
                return res.json({ results: [] });
            }

            // Check if search service is available
            if (!this.searchService) {
                logger.warn('Search service not available, returning empty results');
                return res.json({
                    results: [],
                    error: 'Search service not available (SPARQL endpoints unreachable)'
                });
            }
            
            logger.info(`Search service available, initialized: ${this.searchService.initialized}`);
            
            // Check if search service is properly initialized
            if (!this.searchService.initialized) {
                logger.warn('Search service not initialized, returning empty results');
                return res.json({
                    results: [],
                    error: 'Search service not initialized (still loading embeddings)'
                });
            }

            // Perform search
            const results = await this.searchService.search(query, limit);

            logger.info(`Found ${results.length} results for query: "${query}"`);

            res.json({ results });
        } catch (error) {
            logger.error('Search error:', error);
            res.status(500).json({
                error: 'Search failed',
                message: error.message
            });
        }
    }

    /**
     * Handle health check requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleHealthCheck(req, res) {
        try {
            // Check services status safely
            let chatStatus = 'offline';
            let memoryStatus = 'offline';

            try {
                if (this.chatAPI) {
                    chatStatus = 'online';
                }
            } catch (e) {
                logger.warn('Error checking chat API status:', e);
            }

            try {
                if (this.memoryManager) {
                    memoryStatus = 'online';
                }
            } catch (e) {
                logger.warn('Error checking memory API status:', e);
            }

            const health = {
                status: 'healthy',
                timestamp: new Date().toISOString(),
                uptime: process.uptime(),
                services: {
                    search: this.searchService ? 'online' : 'offline',
                    chat: chatStatus,
                    memory: memoryStatus
                }
            };

            res.json(health);
        } catch (error) {
            logger.error('Health check error:', error);
            res.status(500).json({
                status: 'degraded',
                timestamp: new Date().toISOString(),
                error: error.message
            });
        }
    }

    /**
     * Handle chat API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
    }
    /**
     * Handle chat API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleChat(req, res) {
        try {
            // Validate request
            const {
                prompt,
                conversationId,
                useMemory,
                temperature,
                useSearchInterjection,
                providerId
            } = req.body;

            if (!prompt) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Prompt is required'
                });
            }

            logger.info(`ðŸ” [CHAT DEBUG] Chat request with prompt: "${prompt.slice(0, 30)}..."`);
            logger.info(`ðŸ” [CHAT DEBUG] Request providerId: "${providerId}"`);

            try {
                logger.info(`ðŸ” [CHAT DEBUG] Entering try block for chat processing`);
                // Optionally enrich the prompt with search results if requested
                let enrichedPrompt = prompt;
                let searchResults = [];

                // If search interjection is requested, find relevant content
                if (useSearchInterjection) {
                    try {
                        logger.info('Searching for relevant content to interject...');
                        searchResults = await this.performEmbeddingSearch(prompt);

                        if (searchResults &amp;&amp; searchResults.length > 0) {
                            // Format search results as context
                            const contextBlocks = searchResults.map((result, index) =>
                                `[DOCUMENT ${index + 1}]\nTitle: ${result.title || 'Untitled'}\nContent: ${result.content}\nScore: ${result.score}\n`
                            ).join('\n');

                            // Append context to prompt with instructions
                            enrichedPrompt = `I found some relevant information that might help answer your question. Please consider this information when formulating your response:

${contextBlocks}

Based on the above information and your knowledge, here is the user's question: ${prompt}`;

                            logger.info(`Enriched prompt with ${searchResults.length} search results`);
                        }
                    } catch (searchError) {
                        logger.warn('Failed to enrich prompt with search results:', searchError);
                        // Continue with original prompt if search fails
                    }
                }

                // DEBUG: Log the provider selection process
                logger.info(`ðŸ” [CHAT DEBUG] Received provider ID: "${providerId}"`);
                logger.info(`ðŸ” [CHAT DEBUG] Available chatProviders: ${this.chatProviders?.map(p => `${p.id}:${p.type}`).join(', ')}`);

                // Get the selected provider by ID or use the default (use chatProviders like streaming)
                const selectedProvider = this.chatProviders?.find(p => p.id === providerId) || this.chatProviders?.[0];

                if (!selectedProvider) {
                    throw new Error('No chat provider available');
                }

                logger.info(`ðŸš€ [CHAT DEBUG] Selected provider: ${selectedProvider.type}${selectedProvider.implementation ? ` (${selectedProvider.implementation})` : ''} with ID: ${selectedProvider.id}`);

                // Ensure the provider has a connector (chatProviders should already be initialized)
                if (!selectedProvider.connector) {
                    logger.error(`ðŸš¨ [CHAT DEBUG] Provider ${selectedProvider.type} has no connector! This should not happen with chatProviders.`);
                    throw new Error(`Provider ${selectedProvider.type} is not properly initialized`);
                }

                logger.info(`âœ… [CHAT DEBUG] Provider ${selectedProvider.type} has connector: ${selectedProvider.connector.constructor.name}`);

                // Use the model from the request or fall back to the provider's default
                const modelToUse = req.body.model || selectedProvider.chatModel;
                logger.info(`ðŸŽ¯ [CHAT DEBUG] Using model: ${modelToUse} for provider: ${selectedProvider.type}`);

                // Create chat API with selected provider and model
                const chatAPI = await this.createChatAPI(selectedProvider, modelToUse);
                logger.info(`ðŸ”§ [CHAT DEBUG] Created ChatAPI with provider: ${selectedProvider.type}, connector: ${selectedProvider.connector.constructor.name}`);

                // Generate response with the selected model
                logger.info(`ðŸš€ [CHAT DEBUG] About to execute chat operation with provider: ${selectedProvider.type}`);
                const result = await chatAPI.executeOperation('chat', {
                    prompt: enrichedPrompt, // Use the potentially enriched prompt
                    conversationId,
                    useMemory: useMemory !== false, // Default to true if not specified
                    temperature: temperature || 0.7,
                    model: modelToUse // Use the selected model
                });
                logger.info(`âœ… [CHAT DEBUG] Chat operation completed with provider: ${selectedProvider.type}`);

                // Add search results to the response
                if (searchResults &amp;&amp; searchResults.length > 0) {
                    result.searchResults = searchResults.map(r => ({
                        title: r.title || 'Untitled',
                        content: r.content.substring(0, 200) + (r.content.length > 200 ? '...' : ''),
                        score: r.score
                    }));
                }

                // Return response
                res.json(result);
            } catch (apiError) {
                logger.error('ðŸš¨ [CHAT DEBUG] Chat API error:', apiError);
                logger.error('ðŸš¨ [CHAT DEBUG] Error stack:', apiError.stack);

                // Fallback: Use direct LLM if chatAPI fails
                if (this.llmHandler) {
                    logger.info('Using LLM fallback for chat request');

                    const response = await this.llmHandler.generateResponse(
                        prompt,
                        "", // No context in fallback mode
                        "I'm an AI assistant. How can I help you today?"
                    );

                    res.json({
                        response,
                        conversationId: null,
                        fallback: true
                    });
                } else {
                    throw apiError;
                }
            }
        } catch (error) {
            logger.error('Chat error:', error);
            res.status(500).json({
                error: 'Chat request failed',
                message: error.message
            });
        }
    }

    /**
     * Perform embedding search to find relevant content
     * @param {string} query - The search query
     * @param {number} limit - Maximum number of results to return (default: 3)
     * @param {number} threshold - Similarity threshold (default: 0.6)
     * @returns {Promise&lt;Array>} - Array of search results with content and scores
     */
    async performEmbeddingSearch(query, limit = 3, threshold = 0.6) {
        try {
            logger.info(`Performing embedding search for: "${query.slice(0, 30)}..."`);

            // Check if search service is available
            if (!this.searchService) {
                logger.warn('Search service not available for embedding search');
                return []; // Return empty array if search service is not available
            }

            // Use the search service to find relevant content
            const results = await this.searchService.search(query, limit, threshold);

            // Return formatted results
            return results.map(result => ({
                title: result.title || '',
                content: result.content || '',
                type: result.type || 'unknown',
                score: result.score || 0
            }));
        } catch (error) {
            logger.error('Embedding search error:', error);
            return []; // Return empty array on error
        }
    }

    /**
     * Handle streaming chat API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleChatStream(req, res) {
        try {
            // Validate request
            const {
                prompt,
                conversationId,
                useMemory,
                temperature,
                useSearchInterjection,
                providerId
            } = req.body;

            if (!prompt) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Prompt is required'
                });
            }

            logger.info(`Chat stream request with prompt: "${prompt.slice(0, 30)}..."`);

            // Set up SSE
            res.setHeader('Content-Type', 'text/event-stream');
            res.setHeader('Cache-Control', 'no-cache');
            res.setHeader('Connection', 'keep-alive');

            try {
                // Optionally enrich the prompt with search results if requested
                let enrichedPrompt = prompt;
                let searchResults = [];

                // If search interjection is requested, find relevant content
                if (useSearchInterjection) {
                    try {
                        logger.info('Searching for relevant content to interject...');

                        // Send event about searching
                        res.write(`data: ${JSON.stringify({ info: "Searching for relevant content..." })}\n\n`);

                        searchResults = await this.performEmbeddingSearch(prompt);

                        if (searchResults &amp;&amp; searchResults.length > 0) {
                            // Format search results as context
                            const contextBlocks = searchResults.map((result, index) =>
                                `[DOCUMENT ${index + 1}]\nTitle: ${result.title || 'Untitled'}\nContent: ${result.content}\nScore: ${result.score}\n`
                            ).join('\n');

                            // Append context to prompt with instructions
                            enrichedPrompt = `I found some relevant information that might help answer your question. Please consider this information when formulating your response:

${contextBlocks}

Based on the above information and your knowledge, here is the user's question: ${prompt}`;

                            logger.info(`Enriched prompt with ${searchResults.length} search results`);

                            // Send event about found results
                            res.write(`data: ${JSON.stringify({
                                info: `Found ${searchResults.length} relevant documents`,
                                searchResults: searchResults.map(r => ({
                                    title: r.title || 'Untitled',
                                    snippet: r.content.substring(0, 150) + (r.content.length > 150 ? '...' : ''),
                                    score: r.score
                                }))
                            })}\n\n`);
                        } else {
                            res.write(`data: ${JSON.stringify({ info: "No relevant content found, using general knowledge" })}\n\n`);
                        }
                    } catch (searchError) {
                        logger.warn('Failed to enrich prompt with search results:', searchError);
                        // Continue with original prompt if search fails
                        res.write(`data: ${JSON.stringify({ info: "Search failed, using general knowledge" })}\n\n`);
                    }
                }

                // Get the selected provider or use the default
                const selectedProvider = this.chatProviders?.find(p => p.id === providerId) || this.chatProviders?.[0];

                if (!selectedProvider) {
                    throw new Error('No chat provider available');
                }

                logger.info(`Using provider: ${selectedProvider.type}${selectedProvider.implementation ? ` (${selectedProvider.implementation})` : ''}`);

                // Create chat API with selected provider
                const chatAPI = this.createChatAPI(selectedProvider, selectedProvider.chatModel);

                // Send event that we're generating a response
                res.write(`data: ${JSON.stringify({ info: "Generating response..." })}\n\n`);

                // Generate streaming response
                const stream = await chatAPI.executeOperation('stream', {
                    prompt: enrichedPrompt, // Use the potentially enriched prompt
                    conversationId,
                    useMemory: useMemory !== false,
                    temperature: temperature || 0.7
                });

                // Handle stream events
                stream.on('data', (data) => {
                    res.write(`data: ${JSON.stringify(data)}\n\n`);
                });

                stream.on('error', (error) => {
                    logger.error('Chat stream error:', error);
                    res.write(`data: ${JSON.stringify({ error: error.message })}\n\n`);
                    res.end();
                });

                stream.on('end', () => {
                    if (searchResults &amp;&amp; searchResults.length > 0) {
                        // Send final message with sources
                        res.write(`data: ${JSON.stringify({
                            sources: searchResults.map(r => ({
                                title: r.title || 'Untitled',
                                snippet: r.content.substring(0, 150) + (r.content.length > 150 ? '...' : ''),
                                score: r.score
                            }))
                        })}\n\n`);
                    }

                    res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
                    res.end();
                });

                // Handle client disconnect
                req.on('close', () => {
                    stream.removeAllListeners();
                    res.end();
                });
            } catch (apiError) {
                logger.error('Chat API streaming error:', apiError);

                // Fallback: Use direct LLM if chatAPI fails and simulate streaming
                if (this.llmHandler) {
                    logger.info('Using LLM fallback for chat stream request');

                    // Use non-streaming response in fallback mode
                    try {
                        res.write(`data: ${JSON.stringify({ info: "Using fallback response generation..." })}\n\n`);

                        const response = await this.llmHandler.generateResponse(
                            prompt,
                            "", // No context in fallback mode
                            "I'm an AI assistant. How can I help you today?"
                        );

                        // Simulate streaming by sending the whole response at once
                        res.write(`data: ${JSON.stringify({ chunk: response })}\n\n`);
                        res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
                        res.end();
                    } catch (fallbackError) {
                        logger.error('Fallback LLM error:', fallbackError);
                        res.write(`data: ${JSON.stringify({ error: 'Fallback LLM failed: ' + fallbackError.message })}\n\n`);
                        res.end();
                    }
                } else {
                    res.write(`data: ${JSON.stringify({ error: 'Chat API unavailable: ' + apiError.message })}\n\n`);
                    res.end();
                }
            }
        } catch (error) {
            logger.error('Chat stream error:', error);
            // For non-SSE requests that error out before headers are sent
            if (!res.headersSent) {
                res.status(500).json({
                    error: 'Chat stream request failed',
                    message: error.message
                });
            } else {
                res.write(`data: ${JSON.stringify({ error: error.message })}\n\n`);
                res.end();
            }
        }
    }

    /**
     * Handle chat completion API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleChatCompletion(req, res) {
        try {
            // Validate request
            const {
                prompt,
                max_tokens,
                temperature,
                providerId
            } = req.body;

            if (!prompt) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Prompt is required'
                });
            }

            logger.info(`Chat completion request with prompt: "${prompt.slice(0, 30)}..."`);

            // Get the selected provider or use the default
            const selectedProvider = this.chatProviders?.find(p => p.id === providerId) || this.chatProviders?.[0];

            if (!selectedProvider) {
                throw new Error('No chat provider available');
            }

            logger.info(`Using provider: ${selectedProvider.type}${selectedProvider.implementation ? ` (${selectedProvider.implementation})` : ''}`);

            // Create chat API with selected provider
            const chatAPI = this.createChatAPI(selectedProvider, selectedProvider.chatModel);

            // Generate completion
            const result = await chatAPI.executeOperation('completion', {
                prompt,
                max_tokens: max_tokens || 100,
                temperature: temperature || 0.7
            });

            // Return response
            res.json(result);
        } catch (error) {
            logger.error('Chat completion error:', error);
            res.status(500).json({
                error: 'Chat completion request failed',
                message: error.message
            });
        }
    }

    /**
     * Handle memory store API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleMemoryStore(req, res) {
        try {
            // Validate request
            const { prompt, response, metadata } = req.body;

            if (!prompt || !response) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Both prompt and response are required'
                });
            }

            logger.info('Memory store request received');

            // Get memory manager
            const memoryManager = this.apiRegistry.get('memory');

            // Generate embedding and concepts
            const embedding = await memoryManager.generateEmbedding(`${prompt} ${response}`);
            const concepts = await memoryManager.extractConcepts(`${prompt} ${response}`);

            // Store in memory
            await memoryManager.addInteraction(prompt, response, embedding, concepts);

            // Return response
            res.json({
                id: memoryManager.memStore.shortTermMemory[memoryManager.memStore.shortTermMemory.length - 1].id,
                timestamp: Date.now(),
                concepts
            });
        } catch (error) {
            logger.error('Memory store error:', error);
            res.status(500).json({
                error: 'Memory store failed',
                message: error.message
            });
        }
    }

    /**
     * Handle memory search API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleMemorySearch(req, res) {
        try {
            // Get query parameters
            const query = req.query.query || '';
            const limit = parseInt(req.query.limit) || 5;
            const threshold = parseFloat(req.query.threshold) || 0.7;

            if (!query.trim()) {
                return res.json({ results: [] });
            }

            logger.info(`Memory search request for: "${query}" with threshold: ${threshold}`);

            // Get memory manager
            const memoryManager = this.apiRegistry.get('memory');

            // Retrieve memories
            const memories = await memoryManager.retrieveRelevantInteractions(query, threshold);

            // Limit results and format response
            const results = memories.slice(0, limit).map(memory => ({
                id: memory.interaction.id,
                prompt: memory.interaction.prompt,
                output: memory.interaction.output,
                score: memory.similarity,
                timestamp: memory.interaction.timestamp,
                concepts: memory.interaction.concepts
            }));

            res.json({ results });
        } catch (error) {
            logger.error('Memory search error:', error);
            res.status(500).json({
                error: 'Memory search failed',
                message: error.message
            });
        }
    }

    /**
     * Handle embedding generation API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleEmbedding(req, res) {
        try {
            // Validate request
            const { text, model } = req.body;

            if (!text) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Text is required'
                });
            }

            logger.info('Embedding generation request received');

            // Get memory manager
            const memoryManager = this.apiRegistry.get('memory');

            // Generate embedding
            const embedding = await memoryManager.generateEmbedding(text);

            // Return response
            res.json({
                embedding,
                dimension: embedding.length,
                model: model || memoryManager.embeddingModel
            });
        } catch (error) {
            logger.error('Embedding generation error:', error);
            res.status(500).json({
                error: 'Embedding generation failed',
                message: error.message
            });
        }
    }

    /**
     * Handle concept extraction API requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleConcepts(req, res) {
        try {
            // Validate request
            const { text } = req.body;

            if (!text) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Text is required'
                });
            }

            logger.info('Concept extraction request received');

            // Get memory manager
            const memoryManager = this.apiRegistry.get('memory');

            // Extract concepts
            const concepts = await memoryManager.extractConcepts(text);

            // Return response
            res.json({ concepts });
        } catch (error) {
            logger.error('Concept extraction error:', error);
            res.status(500).json({
                error: 'Concept extraction failed',
                message: error.message
            });
        }
    }

    /**
     * Start the server
     * @returns {Promise&lt;void>}
     */
    async start() {
        try {
            // Configure the app
            this.configureApp();

            // Initialize the search service with fallback capability
            logger.info('Initializing search service...');
            await this.initializeSearchServiceWithFallback();

            // Initialize LLM and chat features with fallback capability
            logger.info('Initializing LLM and chat features...');
            await this.initializeChatFeatures();

            // Start the Express server
            this.server = this.app.listen(this.port, () => {
                logger.info(`UI server running at http://localhost:${this.port}`);
            });
        } catch (error) {
            logger.error('Failed to start server:', error);
            throw error;
        }
    }

    /**
     * Initialize search service with fallback to alternative SPARQL endpoints if needed
     */
    async initializeSearchServiceWithFallback() {
        let lastError = null;

        // Try each SPARQL endpoint in order until one works
        for (let i = 0; i &lt; this.sparqlEndpoints.length; i++) {
            const endpoint = this.sparqlEndpoints[i];

            try {
                logger.info(`Trying SPARQL endpoint ${i + 1}/${this.sparqlEndpoints.length}: ${endpoint.queryEndpoint}`);

                // If not the first endpoint, create a new SPARQL service with this endpoint
                if (i > 0) {
                    this.sparqlService = new SPARQLService({
                        queryEndpoint: endpoint.queryEndpoint,
                        updateEndpoint: endpoint.updateEndpoint,
                        graphName: this.graphName,
                        auth: endpoint.auth
                    });

                    // Update the search service with the new SPARQL service
                    this.searchService = new SearchService({
                        embeddingService: this.embeddingService,
                        sparqlService: this.sparqlService,
                        graphName: this.graphName
                    });
                }

                // Try to initialize with this endpoint
                await this.searchService.initialize();

                // If we get here, initialization succeeded
                logger.info(`Successfully connected to SPARQL endpoint: ${endpoint.queryEndpoint}`);
                return;
            } catch (error) {
                lastError = error;
                logger.warn(`Failed to connect to SPARQL endpoint ${endpoint.queryEndpoint}:`, error.message);
            }
        }

        // If we get here, all endpoints failed
        logger.warn(`All SPARQL endpoints failed, but continuing without search service. Last error:`, lastError?.message);
        // Don't throw error - allow server to start without SPARQL connectivity
        this.searchService = null;
    }

    /**
     * Initialize chat features and register API
     */
    async initializeChatFeatures() {
        try {
            // Try each LLM provider in priority order
            const availableProviders = await this.initializeLLMProvidersWithFallback();

            if (availableProviders.length === 0) {
                throw new Error('No LLM providers available. Unable to initialize chat features.');
            }

            // Select the best provider for each capability
            const chatProvider = this.chatProviders.find(p => p.type === 'claude') || this.chatProviders[0];
            const embeddingProvider = this.embeddingProviders.find(p => p.type === 'ollama') || this.embeddingProviders[0];

            if (!chatProvider) {
                logger.error('No chat provider available');
                throw new Error('No chat provider available. Unable to initialize chat features.');
            }

            if (!embeddingProvider) {
                logger.error('No embedding provider available');
                throw new Error('No embedding provider available. Unable to initialize memory features.');
            }

            logger.info(`Using ${chatProvider.type}${chatProvider.implementation ? ` (${chatProvider.implementation})` : ''} for chat`);
            logger.info(`Using ${embeddingProvider.type} for embeddings`);

            // Create memory manager for semantic memory with separate providers for different functions
            logger.info('Initializing memory manager...');
            this.memoryManager = new MemoryManager({
                llmProvider: chatProvider.connector,
                embeddingProvider: embeddingProvider.connector,
                chatModel: chatProvider.chatModel,
                embeddingModel: embeddingProvider.embeddingModel
            });

            // Create LLM handler for direct LLM requests
            logger.info('Initializing LLM handler...');
            this.llmHandler = new LLMHandler(
                chatProvider.connector,
                chatProvider.chatModel
            );

            // Create a custom registry for passing dependencies
            logger.info('Creating custom registry for chat API...');
            try {
                // Create a custom registry object instead of using APIRegistry
                const chatRegistry = {
                    get: (name) => {
                        if (name === 'memory') return this.memoryManager;
                        if (name === 'llm') return this.llmHandler;
                        throw new Error(`API ${name} not found`);
                    }
                };

                // Register only the chat API
                logger.info('Registering Chat API...');
                this.chatAPI = new ChatAPI({
                    registry: chatRegistry,
                    similarityThreshold: 0.7,
                    contextWindow: 5
                });

                // Initialize the chat API
                await this.chatAPI.initialize();

                // Store in apiRegistry (not using register method)
                this.apiRegistry.apis = this.apiRegistry.apis || new Map();
                this.apiRegistry.apis.set('chat', this.chatAPI);

                // Store all available providers for later use
                this.availableLLMProviders = availableProviders;

                logger.info('Chat features initialized successfully');
            } catch (error) {
                logger.error('Failed to initialize chat API:', error);
                throw error;
            }
        } catch (error) {
            logger.error('Failed to initialize chat features:', error);
            throw error;
        }
    }

    /**
     * Handle listing available providers
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleListProviders(req, res) {
        try {
            // Ensure providers are initialized by checking chatProviders
            if (!this.chatProviders || this.chatProviders.length === 0) {
                logger.warn('No chat providers available, trying to initialize...');
                await this.initializeLLMProvidersWithFallback();

                if (!this.chatProviders || this.chatProviders.length === 0) {
                    logger.warn('Still no chat providers available after initialization');
                    return res.json({ providers: [] });
                }
            }

            // Define available models for each provider type
            const providerModels = {
                'mistral': ['mistral-medium', 'mistral-small', 'mistral-tiny'],
                'claude': ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
                'ollama': ['llama3', 'mistral', 'mixtral', 'qwen2:1.5b'],
                'openai': ['gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo']
            };

            // Use initialized chatProviders instead of raw llmProviders
            const providers = this.chatProviders.map(p => {
                const models = providerModels[p.type] || [p.chatModel || 'default'];

                // Add MCP capability if available (for now, mark all as MCP-capable for demo)
                const capabilities = p.capabilities || [];

                // Check if MCP server is running and add MCP capability
                const hasMCPSupport = true; // All providers can potentially use MCP tools
                if (hasMCPSupport &amp;&amp; !capabilities.includes('mcp')) {
                    capabilities.push('mcp');
                }

                return {
                    id: p.id,  // Use the actual provider ID from chatProviders
                    type: p.type,
                    name: `${p.type}${p.implementation ? ` (${p.implementation})` : ''}`,
                    model: p.chatModel || 'default',
                    models: models,  // Include available models
                    capabilities: capabilities,
                    implementation: p.implementation || 'default',
                    mcpSupported: hasMCPSupport,
                    isInitialized: !!p.connector // Show if the provider has a working connector
                };
            });

            logger.info(`Returning ${providers.length} available chat providers`);
            res.json({ providers });
        } catch (error) {
            logger.error('Error listing providers:', error);
            res.status(500).json({
                error: 'Failed to list providers',
                message: error.message
            });
        }
    }

    /**
     * Create a chat API instance with the specified provider
     * @param {Object} provider - The provider configuration
     * @param {string} model - The model to use
     * @returns {Promise&lt;Object>} Configured ChatAPI instance
     */
    async createChatAPI(provider, model) {
        if (!provider.connector) {
            throw new Error(`Provider ${provider.type} has no connector`);
        }

        // Ensure the provider's connector is initialized
        try {
            await provider.connector.initialize();
            logger.debug(`Successfully initialized ${provider.type} connector`);
        } catch (error) {
            logger.error(`Failed to initialize ${provider.type} connector:`, error);
            throw new Error(`Failed to initialize ${provider.type} provider: ${error.message}`);
        }

        // Verify the connector is properly initialized
        if (!provider.connector.client) {
            throw new Error(`${provider.type} connector client is not initialized`);
        }

        try {
            const memoryManager = new MemoryManager({
                llmProvider: provider.connector,
                chatModel: model || provider.chatModel,
                embeddingProvider: this.embeddingProviders[0]?.connector,
                embeddingModel: this.embeddingProviders[0]?.embeddingModel
            });

            const llmHandler = new LLMHandler(provider.connector, model || provider.chatModel);

            const registry = {
                get: (name) => {
                    if (name === 'memory') return memoryManager;
                    if (name === 'llm') return llmHandler;
                    throw new Error(`API ${name} not found`);
                }
            };

            return new ChatAPI({
                registry,
                similarityThreshold: 0.7,
                contextWindow: 5
            });
        } catch (error) {
            logger.error(`Error creating chat API for ${provider.type}:`, error);
            throw new Error(`Failed to create chat API: ${error.message}`);
        }
    }

    async initializeLLMProvidersWithFallback() {
        const availableProviders = [];
        const embeddingProviders = [];
        const chatProviders = [];
        let providerCounter = 0;

        // Try each provider and categorize them based on capabilities
        const sortedProviders = [...this.llmProviders].sort((a, b) => a.priority - b.priority);

        for (const provider of sortedProviders) {
            try {
                logger.info(`Trying LLM provider: ${provider.type}`);

                // Initialize the appropriate connector based on provider type
                let connector;

                switch (provider.type) {
                    case 'mistral':
                        if (!provider.apiKey) {
                            logger.warn('Skipping Mistral provider - no API key provided');
                            continue;
                        }
                        // Create and attach the connector to the provider
                        provider.connector = new MistralConnector(
                            provider.apiKey,
                            provider.baseUrl,
                            provider.chatModel
                        );
                        logger.info('Mistral AI connector created and attached to provider');
                        connector = provider.connector; // Set the local connector variable as well
                        break;

                    case 'ollama':
                        // Create and attach the connector to the provider
                        provider.connector = new OllamaConnector({
                            baseUrl: provider.baseUrl,
                            chatModel: provider.chatModel,
                            embeddingModel: provider.embeddingModel
                        });
                        logger.info('Ollama connector created and attached to provider');
                        connector = provider.connector; // Set the local connector variable as well
                        break;

                    case 'claude':
                        if (!provider.apiKey) {
                            logger.warn('Skipping Claude provider - no API key provided');
                            continue;
                        }

                        // Use hyperdata-clients implementation for Claude
                        provider.connector = new HClaudeClientConnector(
                            provider.apiKey,
                            provider.chatModel
                        );
                        logger.info('Claude connector created and attached to provider');
                        connector = provider.connector; // Set the local connector variable as well
                        break;

                    case 'openai':
                        // Placeholder for OpenAI connector - you'll need to implement or import this
                        if (!provider.apiKey) {
                            logger.warn('Skipping OpenAI provider - no API key provided');
                            continue;
                        }
                        // For now, we'll skip OpenAI since we don't have the connector implementation
                        logger.warn('OpenAI provider not yet implemented, skipping');
                        continue;

                    default:
                        logger.warn(`Unknown provider type: ${provider.type}, skipping`);
                        continue;
                }

                // Test the connector for chat capabilities
                try {
                    // Try a simple chat test if possible
                    if (typeof connector.generateChat === 'function') {
                        // Just check if the function exists, no need to actually call it
                        logger.info(`${provider.type} provider has chat capabilities`);

                        // Add to chat providers with unique ID
                        chatProviders.push({
                            ...provider,
                            id: `provider-${providerCounter}`,
                            connector,
                            capabilities: ['chat']
                        });
                        providerCounter++;
                    }
                } catch (chatError) {
                    logger.warn(`Provider ${provider.type} chat capability check failed:`, chatError.message);
                }

                // Test the connector for embedding capabilities
                try {
                    // Only test Ollama for embeddings
                    if (provider.type === 'ollama') {
                        await connector.generateEmbedding(
                            provider.embeddingModel,
                            'Test embedding generation'
                        );

                        logger.info(`${provider.type} provider has embedding capabilities`);

                        // Add to embedding providers with unique ID
                        embeddingProviders.push({
                            ...provider,
                            id: `provider-${providerCounter}`,
                            connector,
                            capabilities: ['embedding']
                        });
                        providerCounter++;
                    }
                } catch (embeddingError) {
                    logger.warn(`Provider ${provider.type} embedding test failed:`, embeddingError.message);
                }

                // Add to available providers if it has any capabilities
                if (
                    chatProviders.some(p => p.connector === connector) ||
                    embeddingProviders.some(p => p.connector === connector)
                ) {
                    // Determine capabilities
                    const capabilities = [];
                    if (chatProviders.some(p => p.connector === connector)) capabilities.push('chat');
                    if (embeddingProviders.some(p => p.connector === connector)) capabilities.push('embedding');

                    availableProviders.push({
                        ...provider,
                        connector,
                        capabilities
                    });

                    logger.info(`Successfully connected to ${provider.type} provider with capabilities: ${capabilities.join(', ')}`);
                }

            } catch (error) {
                logger.warn(`Failed to initialize ${provider.type} provider:`, error.message);
            }
        }

        // Log providers by capability
        logger.info(`Found ${chatProviders.length} providers with chat capabilities`);
        logger.info(`Found ${embeddingProviders.length} providers with embedding capabilities`);

        // Store providers by capability for easier access
        this.chatProviders = [...new Map(chatProviders.map(p => [p.id, p])).values()]; // Deduplicate
        this.embeddingProviders = [...new Map(embeddingProviders.map(p => [p.id, p])).values()]; // Deduplicate

        // Log available providers
        logger.info(`Available chat providers: ${this.chatProviders.map(p => `${p.type} (${p.id})`).join(', ')}`);
        logger.info(`Available embedding providers: ${this.embeddingProviders.map(p => `${p.type} (${p.id})`).join(', ')}`);

        return availableProviders;
    }

    /**
     * Transform SPARQL endpoints from Config.js format to UIServer format
     * @param {Array} endpoints - Array of endpoint configurations
     * @returns {Array} Transformed endpoints
     */
    transformEndpoints(endpoints) {
        if (!endpoints || !Array.isArray(endpoints)) {
            return null;
        }

        return endpoints.map(endpoint => {
            // If already in old format, return as-is
            if (endpoint.queryEndpoint &amp;&amp; endpoint.updateEndpoint) {
                return endpoint;
            }

            // If in new Config.js format, transform it
            if (endpoint.urlBase &amp;&amp; endpoint.query &amp;&amp; endpoint.update) {
                return {
                    queryEndpoint: `${endpoint.urlBase}${endpoint.query}`,
                    updateEndpoint: `${endpoint.urlBase}${endpoint.update}`,
                    auth: {
                        user: endpoint.user || 'admin',
                        password: endpoint.password || 'admin'
                    },
                    label: endpoint.label || 'Config Endpoint',
                    dataset: endpoint.dataset
                };
            }

            // Fallback: try to construct from available properties
            console.warn('Unrecognized endpoint format:', endpoint);
            return endpoint;
        });
    }

    /**
     * Handle SPARQL endpoints listing
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlEndpoints(req, res) {
        try {
            // Return configured SPARQL endpoints
            const endpoints = this.sparqlEndpoints.map((endpoint, index) => ({
                id: `endpoint-${index}`,
                name: endpoint.label || `SPARQL Endpoint ${index + 1}`,
                label: endpoint.label || `SPARQL Endpoint ${index + 1}`,
                queryUrl: endpoint.queryEndpoint,
                queryEndpoint: endpoint.queryEndpoint, // For backward compatibility
                updateUrl: endpoint.updateEndpoint,
                updateEndpoint: endpoint.updateEndpoint, // For backward compatibility
                defaultGraph: this.graphName,
                dataset: endpoint.dataset,
                auth: endpoint.auth ? { username: endpoint.auth.user } : null // Don't expose password
            }));

            res.json({ endpoints });
        } catch (error) {
            logger.error('Error listing SPARQL endpoints:', error);
            res.status(500).json({
                error: 'Failed to list SPARQL endpoints',
                message: error.message
            });
        }
    }

    /**
     * Handle SPARQL SELECT queries
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlQuery(req, res) {
        try {
            const { query, endpoint, limit } = req.body;

            if (!query) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'SPARQL query is required'
                });
            }

            logger.info(`Executing SPARQL query: ${query.substring(0, 100)}...`);

            // Use provided endpoint or default to the first configured one
            const targetEndpoint = endpoint || this.sparqlService.queryEndpoint;

            // Apply limit if requested
            let finalQuery = query;
            if (limit &amp;&amp; !query.toUpperCase().includes('LIMIT')) {
                finalQuery += ` LIMIT ${limit}`;
            }

            const results = await this.sparqlService.executeQuery(finalQuery);

            logger.info('SPARQL query executed successfully');
            res.json(results);
        } catch (error) {
            logger.error('SPARQL query error:', error);
            res.status(500).json({
                error: 'SPARQL query failed',
                message: error.message
            });
        }
    }

    /**
     * Handle SPARQL CONSTRUCT queries
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlConstruct(req, res) {
        try {
            const { query, endpoint, format = 'turtle' } = req.body;

            if (!query) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'SPARQL CONSTRUCT query is required'
                });
            }

            logger.info(`Executing SPARQL CONSTRUCT query: ${query.substring(0, 100)}...`);

            // Use provided endpoint or default to the first configured one
            const targetEndpoint = endpoint || this.sparqlService.queryEndpoint;

            // Execute CONSTRUCT query - this should return RDF data
            const results = await this.sparqlService.executeQuery(query);

            // For CONSTRUCT queries, we want to return the RDF data as text
            // The format depends on the SPARQL service implementation
            let rdfData;
            if (typeof results === 'string') {
                rdfData = results;
            } else if (results.results &amp;&amp; results.results.bindings) {
                // Convert results to simple Turtle format
                rdfData = this.convertBindingsToTurtle(results.results.bindings);
            } else {
                rdfData = '';
            }

            // Analyze RDF data to extract graph information for visualization
            const graphInfo = this.analyzeRdfForVisualization(rdfData, results);

            logger.info('SPARQL CONSTRUCT query executed successfully');

            // Return JSON response with RDF data and metadata for frontend
            res.json({
                success: true,
                query: query,
                endpoint: targetEndpoint,
                rdf: {
                    data: rdfData,
                    format: format,
                    size: rdfData.length,
                    encoding: 'utf-8'
                },
                graph: {
                    nodes: graphInfo.nodes,
                    edges: graphInfo.edges,
                    nodeCount: graphInfo.nodeCount,
                    edgeCount: graphInfo.edgeCount,
                    namespaces: graphInfo.namespaces
                },
                metadata: {
                    timestamp: new Date().toISOString(),
                    executionTime: Date.now() - req.startTime || 0,
                    queryType: 'CONSTRUCT',
                    resultFormat: format
                },
                events: {
                    // Event bus configuration for frontend
                    triggerTurtleEditor: {
                        type: 'rdf-data-loaded',
                        data: {
                            content: rdfData,
                            format: format,
                            source: 'sparql-construct'
                        }
                    },
                    triggerGraphVisualization: {
                        type: 'graph-data-updated',
                        data: {
                            nodes: graphInfo.nodes,
                            edges: graphInfo.edges,
                            layout: 'force-directed',
                            source: 'sparql-construct'
                        }
                    }
                }
            });
        } catch (error) {
            logger.error('SPARQL CONSTRUCT query error:', error);
            res.status(500).json({
                success: false,
                error: 'SPARQL CONSTRUCT query failed',
                message: error.message,
                timestamp: new Date().toISOString()
            });
        }
    }

    /**
     * Handle RDF validation requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlValidate(req, res) {
        try {
            const { content, format } = req.body;

            if (!content) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'RDF content is required'
                });
            }

            logger.info('Validating RDF content...');

            // Simple validation - in a real implementation, you'd use an RDF parser
            let valid = true;
            let errors = [];

            try {
                // Basic syntax checks for Turtle format
                if (format === 'turtle' || !format) {
                    // Check for basic Turtle syntax
                    if (!content.includes('.') &amp;&amp; !content.includes(';')) {
                        valid = false;
                        errors.push('Missing statement terminators (. or ;)');
                    }

                    // Check for balanced angle brackets
                    const openBrackets = (content.match(/&lt;/g) || []).length;
                    const closeBrackets = (content.match(/>/g) || []).length;
                    if (openBrackets !== closeBrackets) {
                        valid = false;
                        errors.push('Unbalanced angle brackets in URIs');
                    }
                }
            } catch (parseError) {
                valid = false;
                errors.push(`Parse error: ${parseError.message}`);
            }

            res.json({
                valid,
                errors: valid ? [] : errors,
                format: format || 'turtle'
            });
        } catch (error) {
            logger.error('RDF validation error:', error);
            res.status(500).json({
                error: 'RDF validation failed',
                message: error.message
            });
        }
    }

    /**
     * Handle RDF insertion requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlInsert(req, res) {
        try {
            const { content, endpoint, graph, format } = req.body;

            if (!content) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'RDF content is required'
                });
            }

            logger.info('Inserting RDF data into SPARQL store...');

            // Use provided endpoint or default to the first configured one
            const targetEndpoint = endpoint || this.sparqlService.updateEndpoint;
            const targetGraph = graph || this.graphName;

            // Create SPARQL UPDATE query to insert the data
            const insertQuery = `
                PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#>
                
                INSERT DATA {
                    GRAPH &lt;${targetGraph}> {
                        ${content}
                    }
                }
            `;

            // Execute the insert query
            await this.sparqlService.executeUpdate(insertQuery);

            logger.info('RDF data inserted successfully');
            res.json({
                success: true,
                message: 'RDF data inserted successfully',
                graph: targetGraph
            });
        } catch (error) {
            logger.error('RDF insertion error:', error);
            res.status(500).json({
                error: 'RDF insertion failed',
                message: error.message
            });
        }
    }

    /**
     * Handle SPARQL endpoint testing
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleSparqlTest(req, res) {
        try {
            const { endpoint } = req.body;

            if (!endpoint) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Endpoint URL is required'
                });
            }

            logger.info(`Testing SPARQL endpoint: ${endpoint}`);

            // Test with a simple ASK query
            const testQuery = 'ASK { ?s ?p ?o }';

            try {
                // Create a temporary SPARQL service for testing
                const testService = new (await import('../embeddings/SPARQLService.js')).default({
                    queryEndpoint: endpoint,
                    graphName: this.graphName
                });

                const result = await testService.executeQuery(testQuery);

                logger.info(`SPARQL endpoint test successful: ${endpoint}`);
                res.json({
                    success: true,
                    message: 'Endpoint is accessible',
                    endpoint: endpoint
                });
            } catch (testError) {
                logger.warn(`SPARQL endpoint test failed: ${endpoint} - ${testError.message}`);
                res.json({
                    success: false,
                    error: testError.message,
                    endpoint: endpoint
                });
            }
        } catch (error) {
            logger.error('SPARQL endpoint test error:', error);
            res.status(500).json({
                error: 'Endpoint test failed',
                message: error.message
            });
        }
    }

    /**
     * Analyze RDF data to extract graph information for visualization
     * @param {string} rdfData - RDF data in Turtle format
     * @param {Object} rawResults - Raw results from SPARQL service
     * @returns {Object} Graph information with nodes, edges, and metadata
     */
    analyzeRdfForVisualization(rdfData, rawResults) {
        const nodes = new Map();
        const edges = [];
        const namespaces = new Set();

        try {
            // Parse RDF data to extract graph structure
            const lines = rdfData.split('\n').filter(line => line.trim() &amp;&amp; !line.trim().startsWith('#'));

            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('@prefix') || trimmedLine.startsWith('PREFIX')) {
                    // Extract namespace prefixes
                    const nsMatch = trimmedLine.match(/@prefix\s+(\w+):\s+&lt;([^>]+)>/);
                    if (nsMatch) {
                        namespaces.add({
                            prefix: nsMatch[1],
                            uri: nsMatch[2]
                        });
                    }
                    return;
                }

                // Parse triple statements (basic implementation)
                const tripleMatch = trimmedLine.match(/(&lt;[^>]+>|\w+:\w+)\s+(&lt;[^>]+>|\w+:\w+)\s+(&lt;[^>]+>|"[^"]*"|\w+:\w+)/);
                if (tripleMatch) {
                    const subject = tripleMatch[1];
                    const predicate = tripleMatch[2];
                    const object = tripleMatch[3];

                    // Add subject node
                    if (!nodes.has(subject)) {
                        nodes.set(subject, {
                            id: subject,
                            label: this.extractLabelFromUri(subject),
                            type: this.determineNodeType(subject),
                            uri: subject.startsWith('&lt;') ? subject.slice(1, -1) : subject,
                            properties: {}
                        });
                    }

                    // Add object node if it's a URI (not a literal)
                    if (object.startsWith('&lt;') || (object.includes(':') &amp;&amp; !object.startsWith('"'))) {
                        if (!nodes.has(object)) {
                            nodes.set(object, {
                                id: object,
                                label: this.extractLabelFromUri(object),
                                type: this.determineNodeType(object),
                                uri: object.startsWith('&lt;') ? object.slice(1, -1) : object,
                                properties: {}
                            });
                        }

                        // Add edge between subject and object
                        edges.push({
                            id: `edge-${edges.length}`,
                            source: subject,
                            target: object,
                            predicate: predicate,
                            label: this.extractLabelFromUri(predicate),
                            uri: predicate.startsWith('&lt;') ? predicate.slice(1, -1) : predicate
                        });
                    } else {
                        // Add literal value as property
                        const subjectNode = nodes.get(subject);
                        if (subjectNode) {
                            const propertyName = this.extractLabelFromUri(predicate);
                            subjectNode.properties[propertyName] = object.startsWith('"') ?
                                object.slice(1, -1) : object;
                        }
                    }
                }
            });
        } catch (parseError) {
            logger.warn('Error parsing RDF for visualization:', parseError);
        }

        // Convert Maps to Arrays for JSON serialization
        const nodeArray = Array.from(nodes.values());
        const namespaceArray = Array.from(namespaces);

        return {
            nodes: nodeArray,
            edges: edges,
            nodeCount: nodeArray.length,
            edgeCount: edges.length,
            namespaces: namespaceArray
        };
    }

    /**
     * Extract a readable label from a URI
     * @param {string} uri - The URI to extract label from
     * @returns {string} Readable label
     */
    extractLabelFromUri(uri) {
        if (!uri) return 'Unknown';

        // Remove angle brackets if present
        const cleanUri = uri.startsWith('&lt;') ? uri.slice(1, -1) : uri;

        // Handle prefixed names
        if (cleanUri.includes(':') &amp;&amp; !cleanUri.startsWith('http')) {
            return cleanUri.split(':').pop();
        }

        // Extract last part of URI path
        const parts = cleanUri.split(/[/#]/);
        const lastPart = parts[parts.length - 1];

        // Clean up the label
        return lastPart
            .replace(/([A-Z])/g, ' $1') // Add spaces before capital letters
            .replace(/[-_]/g, ' ') // Replace hyphens and underscores with spaces
            .trim()
            .toLowerCase()
            .replace(/^\w/, c => c.toUpperCase()); // Capitalize first letter
    }

    /**
     * Determine node type based on URI patterns
     * @param {string} uri - The URI to analyze
     * @returns {string} Node type
     */
    determineNodeType(uri) {
        if (!uri) return 'unknown';

        const cleanUri = uri.startsWith('&lt;') ? uri.slice(1, -1) : uri;

        // Common RDF/RDFS/OWL patterns
        if (cleanUri.includes('rdf-schema') || cleanUri.includes('rdfs')) return 'schema';
        if (cleanUri.includes('rdf-syntax') || cleanUri.includes('rdf#')) return 'rdf';
        if (cleanUri.includes('owl')) return 'ontology';
        if (cleanUri.includes('foaf')) return 'person';
        if (cleanUri.includes('dc') || cleanUri.includes('dublin')) return 'metadata';
        if (cleanUri.includes('skos')) return 'concept';

        // Ragno-specific patterns
        if (cleanUri.includes('ragno')) {
            if (cleanUri.includes('Entity')) return 'entity';
            if (cleanUri.includes('SemanticUnit')) return 'semantic-unit';
            if (cleanUri.includes('Relationship')) return 'relationship';
        }

        // Default classification
        if (cleanUri.includes('#type') || cleanUri.includes('type')) return 'type';
        if (cleanUri.includes('Class')) return 'class';
        if (cleanUri.includes('Property')) return 'property';

        return 'resource';
    }

    /**
     * Convert SPARQL bindings to simple Turtle format
     * @param {Array} bindings - SPARQL query bindings
     * @returns {string} Turtle-formatted RDF
     */
    convertBindingsToTurtle(bindings) {
        if (!bindings || bindings.length === 0) {
            return '';
        }

        const triples = bindings.map(binding => {
            const s = binding.s ? (binding.s.type === 'uri' ? `&lt;${binding.s.value}>` : binding.s.value) : '';
            const p = binding.p ? (binding.p.type === 'uri' ? `&lt;${binding.p.value}>` : binding.p.value) : '';
            const o = binding.o ? (
                binding.o.type === 'uri' ? `&lt;${binding.o.value}>` :
                    binding.o.type === 'literal' ? `"${binding.o.value}"` :
                        binding.o.value
            ) : '';

            if (s &amp;&amp; p &amp;&amp; o) {
                return `${s} ${p} ${o} .`;
            }
            return '';
        }).filter(triple => triple);

        return triples.join('\n');
    }

    /**
     * Handle memory graph visualization requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleMemoryGraph(req, res) {
        try {
            const { limit = 50, threshold = 0.7 } = req.body;

            if (!this.chatAPI) {
                return res.status(503).json({
                    error: 'Memory system not available',
                    memories: [],
                    concepts: []
                });
            }

            // Get memory data from the memory manager
            const memoryManager = this.chatAPI.memoryManager;
            if (!memoryManager || !memoryManager.memStore) {
                return res.status(503).json({
                    error: 'Memory store not available',
                    memories: [],
                    concepts: []
                });
            }

            const memStore = memoryManager.memStore;

            // Get memories from both short-term and long-term memory
            const shortTermMemories = memStore.shortTermMemory || [];
            const longTermMemories = memStore.longTermMemory || [];
            const allMemories = [...shortTermMemories, ...longTermMemories];

            // Limit the number of memories
            const limitedMemories = allMemories.slice(0, parseInt(limit));

            // Extract concepts from memories
            const conceptMap = new Map();
            limitedMemories.forEach(memory => {
                const concepts = memory.concepts || [];
                concepts.forEach(concept => {
                    if (!conceptMap.has(concept)) {
                        conceptMap.set(concept, {
                            id: concept,
                            name: concept,
                            weight: 1,
                            memories: []
                        });
                    }
                    conceptMap.get(concept).memories.push(memory.id);
                    conceptMap.get(concept).weight += 1;
                });
            });

            const concepts = Array.from(conceptMap.values());

            // Format memories for graph visualization
            const formattedMemories = limitedMemories.map(memory => ({
                id: memory.id,
                prompt: memory.prompt || '',
                response: memory.output || memory.response || '',
                timestamp: memory.timestamp || Date.now(),
                concepts: memory.concepts || [],
                accessCount: memory.accessCount || 0,
                decayFactor: memory.decayFactor || 1.0,
                type: memory.type || (memory.prompt ? 'user' : 'assistant'),
                embedding: memory.embedding ? memory.embedding.slice(0, 10) : [] // First 10 dimensions for preview
            }));

            res.json({
                memories: formattedMemories,
                concepts: concepts,
                stats: {
                    totalMemories: allMemories.length,
                    shortTermCount: shortTermMemories.length,
                    longTermCount: longTermMemories.length,
                    conceptCount: concepts.length
                }
            });

        } catch (error) {
            console.error('Error in handleMemoryGraph:', error);
            res.status(500).json({
                error: 'Failed to generate memory graph data',
                memories: [],
                concepts: []
            });
        }
    }

    /**
     * Handle memory timeline visualization requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleMemoryTimeline(req, res) {
        try {
            const { period = 'week', grouping = 'day', showAccess = true } = req.body;

            if (!this.chatAPI || !this.chatAPI.memoryManager || !this.chatAPI.memoryManager.memStore) {
                return res.status(503).json({
                    error: 'Memory system not available',
                    timeline: []
                });
            }

            const memStore = this.chatAPI.memoryManager.memStore;
            const allMemories = [...(memStore.shortTermMemory || []), ...(memStore.longTermMemory || [])];

            // Calculate time range
            const now = new Date();
            let startTime;
            switch (period) {
                case 'day':
                    startTime = new Date(now - 24 * 60 * 60 * 1000);
                    break;
                case 'week':
                    startTime = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'month':
                    startTime = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    break;
                default: // 'all'
                    startTime = new Date(0);
            }

            // Filter memories by time range
            const filteredMemories = allMemories.filter(memory =>
                new Date(memory.timestamp) >= startTime
            );

            // Group memories by time period
            const timelineData = new Map();

            filteredMemories.forEach(memory => {
                const date = new Date(memory.timestamp);
                let groupKey;

                switch (grouping) {
                    case 'hour':
                        groupKey = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours()).toISOString();
                        break;
                    case 'day':
                        groupKey = new Date(date.getFullYear(), date.getMonth(), date.getDate()).toISOString();
                        break;
                    case 'week':
                        const weekStart = new Date(date);
                        weekStart.setDate(date.getDate() - date.getDay());
                        groupKey = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate()).toISOString();
                        break;
                    case 'month':
                        groupKey = new Date(date.getFullYear(), date.getMonth(), 1).toISOString();
                        break;
                    default:
                        groupKey = new Date(date.getFullYear(), date.getMonth(), date.getDate()).toISOString();
                }

                if (!timelineData.has(groupKey)) {
                    timelineData.set(groupKey, {
                        date: new Date(groupKey),
                        memoryCount: 0,
                        accessCount: 0,
                        memories: []
                    });
                }

                const entry = timelineData.get(groupKey);
                entry.memoryCount += 1;
                entry.accessCount += memory.accessCount || 0;
                entry.memories.push({
                    id: memory.id,
                    prompt: memory.prompt || '',
                    timestamp: memory.timestamp
                });
            });

            // Convert to array and sort by date
            const timeline = Array.from(timelineData.values()).sort((a, b) => a.date - b.date);

            res.json({
                timeline: timeline,
                period: period,
                grouping: grouping,
                showAccess: showAccess,
                stats: {
                    totalPeriods: timeline.length,
                    totalMemories: filteredMemories.length,
                    avgMemoriesPerPeriod: timeline.length > 0 ? filteredMemories.length / timeline.length : 0
                }
            });

        } catch (error) {
            console.error('Error in handleMemoryTimeline:', error);
            res.status(500).json({
                error: 'Failed to generate timeline data',
                timeline: []
            });
        }
    }

    /**
     * Handle memory clusters visualization requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleMemoryClusters(req, res) {
        try {
            const { clusterCount = 5, method = 'kmeans' } = req.body;

            if (!this.chatAPI || !this.chatAPI.memoryManager || !this.chatAPI.memoryManager.memStore) {
                return res.status(503).json({
                    error: 'Memory system not available',
                    clusters: []
                });
            }

            const memStore = this.chatAPI.memoryManager.memStore;
            const allMemories = [...(memStore.shortTermMemory || []), ...(memStore.longTermMemory || [])];

            if (allMemories.length === 0) {
                return res.json({
                    clusters: [],
                    method: method,
                    stats: { totalClusters: 0, totalMemories: 0 }
                });
            }

            // Simple clustering based on concepts
            const clusters = [];
            const conceptClusters = new Map();

            // Group memories by their primary concepts
            allMemories.forEach(memory => {
                const concepts = memory.concepts || [];
                const primaryConcept = concepts.length > 0 ? concepts[0] : 'uncategorized';

                if (!conceptClusters.has(primaryConcept)) {
                    conceptClusters.set(primaryConcept, []);
                }
                conceptClusters.get(primaryConcept).push(memory);
            });

            // Convert to cluster format
            let clusterId = 0;
            for (const [concept, memories] of conceptClusters.entries()) {
                if (clusterId >= parseInt(clusterCount)) break;

                clusters.push({
                    id: clusterId,
                    label: `Cluster ${clusterId + 1}: ${concept}`,
                    concept: concept,
                    memories: memories.map(memory => ({
                        id: memory.id,
                        prompt: memory.prompt || '',
                        response: memory.output || memory.response || '',
                        timestamp: memory.timestamp,
                        similarity: Math.random() * 0.5 + 0.5 // Mock similarity for now
                    })),
                    centroid: [Math.random() * 100, Math.random() * 100], // Mock centroid
                    size: memories.length
                });
                clusterId++;
            }

            // Calculate statistics
            const stats = {
                totalClusters: clusters.length,
                totalMemories: allMemories.length,
                largestCluster: Math.max(...clusters.map(c => c.size), 0),
                smallestCluster: Math.min(...clusters.map(c => c.size), 0),
                avgClusterSize: clusters.length > 0 ? allMemories.length / clusters.length : 0
            };

            res.json({
                clusters: clusters,
                method: method,
                clusterCount: parseInt(clusterCount),
                stats: stats
            });

        } catch (error) {
            console.error('Error in handleMemoryClusters:', error);
            res.status(500).json({
                error: 'Failed to generate cluster data',
                clusters: []
            });
        }
    }

    /**
     * Handle advanced memory search requests
     * @param {Request} req - The Express request
     * @param {Response} res - The Express response
     */
    async handleAdvancedMemorySearch(req, res) {
        try {
            const {
                query = '',
                searchIn = ['prompt', 'response'],
                dateFrom = null,
                dateTo = null,
                accessCountMin = 0,
                similarityThreshold = 0.7,
                highFrequencyOnly = false,
                recentOnly = false
            } = req.body;

            if (!this.chatAPI || !this.chatAPI.memoryManager || !this.chatAPI.memoryManager.memStore) {
                return res.status(503).json({
                    error: 'Memory system not available',
                    results: [],
                    totalCount: 0
                });
            }

            const startTime = Date.now();
            const memStore = this.chatAPI.memoryManager.memStore;
            let allMemories = [...(memStore.shortTermMemory || []), ...(memStore.longTermMemory || [])];

            // Apply filters
            let filteredMemories = allMemories;

            // Date range filter
            if (dateFrom || dateTo) {
                const fromDate = dateFrom ? new Date(dateFrom) : new Date(0);
                const toDate = dateTo ? new Date(dateTo) : new Date();

                filteredMemories = filteredMemories.filter(memory => {
                    const memoryDate = new Date(memory.timestamp);
                    return memoryDate >= fromDate &amp;&amp; memoryDate &lt;= toDate;
                });
            }

            // Access count filter
            if (accessCountMin > 0) {
                filteredMemories = filteredMemories.filter(memory =>
                    (memory.accessCount || 0) >= accessCountMin
                );
            }

            // High frequency filter
            if (highFrequencyOnly) {
                const avgAccess = allMemories.reduce((sum, m) => sum + (m.accessCount || 0), 0) / allMemories.length;
                filteredMemories = filteredMemories.filter(memory =>
                    (memory.accessCount || 0) > avgAccess
                );
            }

            // Recent filter (last 24 hours)
            if (recentOnly) {
                const dayAgo = Date.now() - (24 * 60 * 60 * 1000);
                filteredMemories = filteredMemories.filter(memory =>
                    memory.timestamp > dayAgo
                );
            }

            // Text search filter
            if (query) {
                const queryLower = query.toLowerCase();
                filteredMemories = filteredMemories.filter(memory => {
                    let matches = false;

                    if (searchIn.includes('prompt') &amp;&amp; memory.prompt) {
                        matches = matches || memory.prompt.toLowerCase().includes(queryLower);
                    }

                    if (searchIn.includes('response') &amp;&amp; (memory.output || memory.response)) {
                        const response = memory.output || memory.response;
                        matches = matches || response.toLowerCase().includes(queryLower);
                    }

                    if (searchIn.includes('concepts') &amp;&amp; memory.concepts) {
                        matches = matches || memory.concepts.some(concept =>
                            concept.toLowerCase().includes(queryLower)
                        );
                    }

                    return matches;
                });
            }

            // Add similarity scores (mock for now)
            const results = filteredMemories.map(memory => ({
                ...memory,
                score: Math.random() * 0.5 + 0.5, // Mock similarity score
                response: memory.output || memory.response || '' // Normalize response field
            }));

            // Sort by relevance (score) descending
            results.sort((a, b) => (b.score || 0) - (a.score || 0));

            const executionTime = Date.now() - startTime;

            res.json({
                results: results,
                totalCount: results.length,
                executionTime: executionTime,
                filters: {
                    query,
                    searchIn,
                    dateFrom,
                    dateTo,
                    accessCountMin,
                    similarityThreshold,
                    highFrequencyOnly,
                    recentOnly
                }
            });

        } catch (error) {
            console.error('Error in handleAdvancedMemorySearch:', error);
            res.status(500).json({
                error: 'Failed to execute advanced search',
                results: [],
                totalCount: 0
            });
        }
    }

    /**
     * Stop the server
     * @returns {Promise&lt;void>}
     */
    async stop() {
        try {
            // Shutdown API services first
            if (this.apiRegistry) {
                logger.info('Shutting down API services...');
                await this.apiRegistry.shutdownAll();
            }

            // Clean up memory manager if needed
            if (this.memoryManager) {
                logger.info('Disposing memory manager...');
                await this.memoryManager.dispose();
            }

            // Stop the HTTP server
            if (this.server) {
                logger.info('Stopping HTTP server...');
                await new Promise((resolve, reject) => {
                    this.server.close((err) => {
                        if (err) {
                            logger.error('Error shutting down server:', err);
                            reject(err);
                        } else {
                            logger.info('Server shut down successfully');
                            resolve();
                        }
                    });
                });
            }
        } catch (error) {
            logger.error('Error during server shutdown:', error);
            throw error;
        }
    }
}

export default UIServer;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-services_document.html">services/document</a></li></ul><h3>Classes</h3><ul><li><a href="APIServer.html">APIServer</a></li><li><a href="ApiService.html">ApiService</a></li><li><a href="AskOperationTimer.html">AskOperationTimer</a></li><li><a href="BaseVisualization.html">BaseVisualization</a></li><li><a href="ChatManager.html">ChatManager</a></li><li><a href="ClientConnector.html">ClientConnector</a></li><li><a href="Clustering.html">Clustering</a></li><li><a href="CommunityElement.html">CommunityElement</a></li><li><a href="ConsoleService.html">ConsoleService</a></li><li><a href="DomUtils.html">DomUtils</a></li><li><a href="EmbeddingCreator.html">EmbeddingCreator</a></li><li><a href="EmbeddingService.html">EmbeddingService</a></li><li><a href="FeatureFlags.html">FeatureFlags</a></li><li><a href="FeatureMaps.html">FeatureMaps</a></li><li><a href="GradualMigration.html">GradualMigration</a></li><li><a href="GraphAPI.html">GraphAPI</a></li><li><a href="HTML2MD.html">HTML2MD</a></li><li><a href="LogCyclingManager.html">LogCyclingManager</a></li><li><a href="MCPClient.html">MCPClient</a></li><li><a href="MCPPromptsCompat.html">MCPPromptsCompat</a></li><li><a href="MemoryAdvancedSearch.html">MemoryAdvancedSearch</a></li><li><a href="MemoryClustersViz.html">MemoryClustersViz</a></li><li><a href="MemoryGraphViz.html">MemoryGraphViz</a></li><li><a href="MemoryTimelineViz.html">MemoryTimelineViz</a></li><li><a href="MemoryVisualizationManager.html">MemoryVisualizationManager</a></li><li><a href="MigrationHelper.html">MigrationHelper</a></li><li><a href="OperationTimer.html">OperationTimer</a></li><li><a href="OperationTracker.html">OperationTracker</a></li><li><a href="Processor.html">Processor</a></li><li><a href="PromptContext.html">PromptContext</a></li><li><a href="PromptFormatterCompat.html">PromptFormatterCompat</a></li><li><a href="PromptMetrics.html">PromptMetrics</a></li><li><a href="PromptOptions.html">PromptOptions</a></li><li><a href="PromptResult.html">PromptResult</a></li><li><a href="PromptTemplate.html">PromptTemplate</a></li><li><a href="PromptTemplatesCompat.html">PromptTemplatesCompat</a></li><li><a href="PromptValidation.html">PromptValidation</a></li><li><a href="RagnoAPIServer.html">RagnoAPIServer</a></li><li><a href="SOMGrid.html">SOMGrid</a></li><li><a href="SPARQLService.html">SPARQLService</a></li><li><a href="SearchAPIEnhanced.html">SearchAPIEnhanced</a></li><li><a href="SearchServer.html">SearchServer</a></li><li><a href="SearchService.html">SearchService</a></li><li><a href="StructuredLogger.html">StructuredLogger</a></li><li><a href="StructuredLoggerFactory.html">StructuredLoggerFactory</a></li><li><a href="TabManager.html">TabManager</a></li><li><a href="TellOperationTimer.html">TellOperationTimer</a></li><li><a href="TrainingViz.html">TrainingViz</a></li><li><a href="UIServer.html">UIServer</a></li><li><a href="VSOMController.html">VSOMController</a></li><li><a href="VSOMService.html">VSOMService</a></li><li><a href="VSOMVisualization.html">VSOMVisualization</a></li><li><a href="ZPTDataFactory.html">ZPTDataFactory</a></li><li><a href="ZPTQueryBuilder.html">ZPTQueryBuilder</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#INCOMPLETE_PATTERNS">INCOMPLETE_PATTERNS</a></li><li><a href="global.html#NamespaceUtils">NamespaceUtils</a></li><li><a href="global.html#PromptTemplates">PromptTemplates</a></li><li><a href="global.html#SPARQL_PREFIXES">SPARQL_PREFIXES</a></li><li><a href="global.html#UnifiedPromptSystem">UnifiedPromptSystem</a></li><li><a href="global.html#ZPTQueryTemplates">ZPTQueryTemplates</a></li><li><a href="global.html#ZPTQueryUtils">ZPTQueryUtils</a></li><li><a href="global.html#ZPTUtils">ZPTUtils</a></li><li><a href="global.html#ZPT_STRING_MAPPINGS">ZPT_STRING_MAPPINGS</a></li><li><a href="global.html#ZPT_URI_MAPPINGS">ZPT_URI_MAPPINGS</a></li><li><a href="global.html#_adjustEmbeddingLength">_adjustEmbeddingLength</a></li><li><a href="global.html#_analyzeQuery">_analyzeQuery</a></li><li><a href="global.html#_buildContext">_buildContext</a></li><li><a href="global.html#_buildFilterClauses">_buildFilterClauses</a></li><li><a href="global.html#_calculateCosineSimilarity">_calculateCosineSimilarity</a></li><li><a href="global.html#_calculateFinalScore">_calculateFinalScore</a></li><li><a href="global.html#_callChat">_callChat</a></li><li><a href="global.html#_callCompletion">_callCompletion</a></li><li><a href="global.html#_createConversation">_createConversation</a></li><li><a href="global.html#_createCorpusInterface">_createCorpusInterface</a></li><li><a href="global.html#_createResult">_createResult</a></li><li><a href="global.html#_determineStrategy">_determineStrategy</a></li><li><a href="global.html#_emitMetric">_emitMetric</a></li><li><a href="global.html#_escapeProperty">_escapeProperty</a></li><li><a href="global.html#_escapeTripleQuotedString">_escapeTripleQuotedString</a></li><li><a href="global.html#_estimateServiceRelevance">_estimateServiceRelevance</a></li><li><a href="global.html#_estimateTokens">_estimateTokens</a></li><li><a href="global.html#_executeArticleLookup">_executeArticleLookup</a></li><li><a href="global.html#_executeBatchSearch">_executeBatchSearch</a></li><li><a href="global.html#_executeCategorySearch">_executeCategorySearch</a></li><li><a href="global.html#_executeConceptDiscovery">_executeConceptDiscovery</a></li><li><a href="global.html#_executeConceptResearch">_executeConceptResearch</a></li><li><a href="global.html#_executeEntityLookup">_executeEntityLookup</a></li><li><a href="global.html#_executeEntitySearch">_executeEntitySearch</a></li><li><a href="global.html#_executeIngest">_executeIngest</a></li><li><a href="global.html#_executeNavigationFallback">_executeNavigationFallback</a></li><li><a href="global.html#_executeParallelSearches">_executeParallelSearches</a></li><li><a href="global.html#_executeSPARQLQuery">_executeSPARQLQuery</a></li><li><a href="global.html#_executeSPARQLUpdate">_executeSPARQLUpdate</a></li><li><a href="global.html#_executeSearch">_executeSearch</a></li><li><a href="global.html#_executeSequentialSearches">_executeSequentialSearches</a></li><li><a href="global.html#_executeServiceSearch">_executeServiceSearch</a></li><li><a href="global.html#_extractCommonResources">_extractCommonResources</a></li><li><a href="global.html#_formatEntity">_formatEntity</a></li><li><a href="global.html#_formatRDFObject">_formatRDFObject</a></li><li><a href="global.html#_formatRelationship">_formatRelationship</a></li><li><a href="global.html#_formatSemanticUnit">_formatSemanticUnit</a></li><li><a href="global.html#_getConversation">_getConversation</a></li><li><a href="global.html#_getWorkflowMetadata">_getWorkflowMetadata</a></li><li><a href="global.html#_handleError">_handleError</a></li><li><a href="global.html#_initializeZPTComponents">_initializeZPTComponents</a></li><li><a href="global.html#_logStep">_logStep</a></li><li><a href="global.html#_measureTime">_measureTime</a></li><li><a href="global.html#_mergeConfig">_mergeConfig</a></li><li><a href="global.html#_normalizeResults">_normalizeResults</a></li><li><a href="global.html#_parseJsonValue">_parseJsonValue</a></li><li><a href="global.html#_parseQueryResults">_parseQueryResults</a></li><li><a href="global.html#_parseSPARQLResults">_parseSPARQLResults</a></li><li><a href="global.html#_rankAndMergeResults">_rankAndMergeResults</a></li><li><a href="global.html#_sanitizeParams">_sanitizeParams</a></li><li><a href="global.html#_searchEntities">_searchEntities</a></li><li><a href="global.html#_searchSemantic">_searchSemantic</a></li><li><a href="global.html#_selectServices">_selectServices</a></li><li><a href="global.html#_serializeTriples">_serializeTriples</a></li><li><a href="global.html#_simpleMergeResults">_simpleMergeResults</a></li><li><a href="global.html#_storeRDFInSPARQL">_storeRDFInSPARQL</a></li><li><a href="global.html#_triplesToJSON">_triplesToJSON</a></li><li><a href="global.html#_updateAverage">_updateAverage</a></li><li><a href="global.html#_validateFile">_validateFile</a></li><li><a href="global.html#_validateInput">_validateInput</a></li><li><a href="global.html#_validateParams">_validateParams</a></li><li><a href="global.html#_validateResources">_validateResources</a></li><li><a href="global.html#adaptiveChunking">adaptiveChunking</a></li><li><a href="global.html#addAltLabel">addAltLabel</a></li><li><a href="global.html#addAlternativeName">addAlternativeName</a></li><li><a href="global.html#addAttribute">addAttribute</a></li><li><a href="global.html#addChunkOverlap">addChunkOverlap</a></li><li><a href="global.html#addChunkRelationships">addChunkRelationships</a></li><li><a href="global.html#addContent">addContent</a></li><li><a href="global.html#addEntityConnection">addEntityConnection</a></li><li><a href="global.html#addEntityMention">addEntityMention</a></li><li><a href="global.html#addEvidence">addEvidence</a></li><li><a href="global.html#addHypothesisToRDF">addHypothesisToRDF</a></li><li><a href="global.html#addInstructions">addInstructions</a></li><li><a href="global.html#addKeyword">addKeyword</a></li><li><a href="global.html#addLabel">addLabel</a></li><li><a href="global.html#addNamespace">addNamespace</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#addNodeToIndex">addNodeToIndex</a></li><li><a href="global.html#addNodesBatch">addNodesBatch</a></li><li><a href="global.html#addNodesToIndex">addNodesToIndex</a></li><li><a href="global.html#addProvenance">addProvenance</a></li><li><a href="global.html#addRelationshipTo">addRelationshipTo</a></li><li><a href="global.html#addSource">addSource</a></li><li><a href="global.html#addToContext">addToContext</a></li><li><a href="global.html#addTooltip">addTooltip</a></li><li><a href="global.html#addTriple">addTriple</a></li><li><a href="global.html#addType">addType</a></li><li><a href="global.html#addUnitConnection">addUnitConnection</a></li><li><a href="global.html#addZoom">addZoom</a></li><li><a href="global.html#adjustForTboxEnvironment">adjustForTboxEnvironment</a></li><li><a href="global.html#advancedEstimation">advancedEstimation</a></li><li><a href="global.html#aggregateCommunities">aggregateCommunities</a></li><li><a href="global.html#aggregationPhase">aggregationPhase</a></li><li><a href="global.html#analyzeCompleteness">analyzeCompleteness</a></li><li><a href="global.html#analyzeConfidenceDistribution">analyzeConfidenceDistribution</a></li><li><a href="global.html#analyzeContentType">analyzeContentType</a></li><li><a href="global.html#analyzeNavigation">analyzeNavigation</a></li><li><a href="global.html#analyzeQuery">analyzeQuery</a></li><li><a href="global.html#analyzeTextStructure">analyzeTextStructure</a></li><li><a href="global.html#applyContentAdjustments">applyContentAdjustments</a></li><li><a href="global.html#applyDeduplication">applyDeduplication</a></li><li><a href="global.html#applyDiversityFilter">applyDiversityFilter</a></li><li><a href="global.html#applyEntityFilter">applyEntityFilter</a></li><li><a href="global.html#applyEntityFilters">applyEntityFilters</a></li><li><a href="global.html#applyFilters">applyFilters</a></li><li><a href="global.html#applyFormatting">applyFormatting</a></li><li><a href="global.html#applyGeographicFilter">applyGeographicFilter</a></li><li><a href="global.html#applyMemoryDomainFilter">applyMemoryDomainFilter</a></li><li><a href="global.html#applyMemoryFilter">applyMemoryFilter</a></li><li><a href="global.html#applyPrivacyFilters">applyPrivacyFilters</a></li><li><a href="global.html#applyRanking">applyRanking</a></li><li><a href="global.html#applyRelevanceFiltering">applyRelevanceFiltering</a></li><li><a href="global.html#applyTemporalFilter">applyTemporalFilter</a></li><li><a href="global.html#applyTokenizerAdjustments">applyTokenizerAdjustments</a></li><li><a href="global.html#applyTopicFilter">applyTopicFilter</a></li><li><a href="global.html#applyTypeFiltering">applyTypeFiltering</a></li><li><a href="global.html#attemptRecovery">attemptRecovery</a></li><li><a href="global.html#augmentWithAttributes">augmentWithAttributes</a></li><li><a href="global.html#balanceChunkSizes">balanceChunkSizes</a></li><li><a href="global.html#batchCountTokens">batchCountTokens</a></li><li><a href="global.html#batchInsertData">batchInsertData</a></li><li><a href="global.html#batchResearch">batchResearch</a></li><li><a href="global.html#beerqaTemplates">beerqaTemplates</a></li><li><a href="global.html#buildAggregationQuery">buildAggregationQuery</a></li><li><a href="global.html#buildBatchConceptInsert">buildBatchConceptInsert</a></li><li><a href="global.html#buildBatchFrequencyUpdate">buildBatchFrequencyUpdate</a></li><li><a href="global.html#buildBatchRelationshipUpdate">buildBatchRelationshipUpdate</a></li><li><a href="global.html#buildCacheKey">buildCacheKey</a></li><li><a href="global.html#buildCommunities">buildCommunities</a></li><li><a href="global.html#buildCompletenessFunction">buildCompletenessFunction</a></li><li><a href="global.html#buildConceptFilter">buildConceptFilter</a></li><li><a href="global.html#buildConceptFilters">buildConceptFilters</a></li><li><a href="global.html#buildConceptQuery">buildConceptQuery</a></li><li><a href="global.html#buildConnectivityFunction">buildConnectivityFunction</a></li><li><a href="global.html#buildConstraints">buildConstraints</a></li><li><a href="global.html#buildContext">buildContext</a></li><li><a href="global.html#buildCriteria">buildCriteria</a></li><li><a href="global.html#buildDiversityFunction">buildDiversityFunction</a></li><li><a href="global.html#buildEntityDetailsQuery">buildEntityDetailsQuery</a></li><li><a href="global.html#buildEntityExtractionPrompt">buildEntityExtractionPrompt</a></li><li><a href="global.html#buildEntityFilter">buildEntityFilter</a></li><li><a href="global.html#buildEntityRule">buildEntityRule</a></li><li><a href="global.html#buildExactMatchQuery">buildExactMatchQuery</a></li><li><a href="global.html#buildFilters">buildFilters</a></li><li><a href="global.html#buildFormattingContext">buildFormattingContext</a></li><li><a href="global.html#buildGeographicFilter">buildGeographicFilter</a></li><li><a href="global.html#buildGeographicRule">buildGeographicRule</a></li><li><a href="global.html#buildGraphFromRDF">buildGraphFromRDF</a></li><li><a href="global.html#buildGraphTraversalQuery">buildGraphTraversalQuery</a></li><li><a href="global.html#buildLimit">buildLimit</a></li><li><a href="global.html#buildOptimizationRules">buildOptimizationRules</a></li><li><a href="global.html#buildOrderBy">buildOrderBy</a></li><li><a href="global.html#buildPrimaryRules">buildPrimaryRules</a></li><li><a href="global.html#buildQuery">buildQuery</a></li><li><a href="global.html#buildRecencyFunction">buildRecencyFunction</a></li><li><a href="global.html#buildRelevanceFunction">buildRelevanceFunction</a></li><li><a href="global.html#buildScoringRules">buildScoringRules</a></li><li><a href="global.html#buildSecondaryRules">buildSecondaryRules</a></li><li><a href="global.html#buildSelectClause">buildSelectClause</a></li><li><a href="global.html#buildSelectionResult">buildSelectionResult</a></li><li><a href="global.html#buildSimilarityFilters">buildSimilarityFilters</a></li><li><a href="global.html#buildSimilarityQuery">buildSimilarityQuery</a></li><li><a href="global.html#buildTemporalFilter">buildTemporalFilter</a></li><li><a href="global.html#buildTemporalRule">buildTemporalRule</a></li><li><a href="global.html#buildTopicFilter">buildTopicFilter</a></li><li><a href="global.html#buildTopicRule">buildTopicRule</a></li><li><a href="global.html#buildTransformationContext">buildTransformationContext</a></li><li><a href="global.html#buildTransitionMatrix">buildTransitionMatrix</a></li><li><a href="global.html#buildTypeFilter">buildTypeFilter</a></li><li><a href="global.html#calculateAttributeConfidence">calculateAttributeConfidence</a></li><li><a href="global.html#calculateCacheHitRate">calculateCacheHitRate</a></li><li><a href="global.html#calculateCentroid">calculateCentroid</a></li><li><a href="global.html#calculateChunkSize">calculateChunkSize</a></li><li><a href="global.html#calculateClusterCentroid">calculateClusterCentroid</a></li><li><a href="global.html#calculateCommunityCohesion">calculateCommunityCohesion</a></li><li><a href="global.html#calculateComplexity">calculateComplexity</a></li><li><a href="global.html#calculateConceptSimilarity">calculateConceptSimilarity</a></li><li><a href="global.html#calculateConfidence">calculateConfidence</a></li><li><a href="global.html#calculateContentSimilarity">calculateContentSimilarity</a></li><li><a href="global.html#calculateCosineSimilarity">calculateCosineSimilarity</a></li><li><a href="global.html#calculateDistance">calculateDistance</a></li><li><a href="global.html#calculateHexagonalDistance">calculateHexagonalDistance</a></li><li><a href="global.html#calculateHybridScore">calculateHybridScore</a></li><li><a href="global.html#calculateLearningRate">calculateLearningRate</a></li><li><a href="global.html#calculateMapDistance">calculateMapDistance</a></li><li><a href="global.html#calculateMemoryImportance">calculateMemoryImportance</a></li><li><a href="global.html#calculateModularity">calculateModularity</a></li><li><a href="global.html#calculateModularityGain">calculateModularityGain</a></li><li><a href="global.html#calculateNeighborhoodRadius">calculateNeighborhoodRadius</a></li><li><a href="global.html#calculateNodeSimilarity">calculateNodeSimilarity</a></li><li><a href="global.html#calculateQualityMetrics">calculateQualityMetrics</a></li><li><a href="global.html#calculateQuantizationError">calculateQuantizationError</a></li><li><a href="global.html#calculateQueryConfidence">calculateQueryConfidence</a></li><li><a href="global.html#calculateRectangularDistance">calculateRectangularDistance</a></li><li><a href="global.html#calculateRelationshipStrength">calculateRelationshipStrength</a></li><li><a href="global.html#calculateSemanticConnectivity">calculateSemanticConnectivity</a></li><li><a href="global.html#calculateSummaryConfidence">calculateSummaryConfidence</a></li><li><a href="global.html#calculateTopographicError">calculateTopographicError</a></li><li><a href="global.html#calculateWeightedScore">calculateWeightedScore</a></li><li><a href="global.html#canResolveFusekiHostname">canResolveFusekiHostname</a></li><li><a href="global.html#checkAPIHealth">checkAPIHealth</a></li><li><a href="global.html#checkContentSimilarity">checkContentSimilarity</a></li><li><a href="global.html#checkContextLimits">checkContextLimits</a></li><li><a href="global.html#checkConvergence">checkConvergence</a></li><li><a href="global.html#checkDependencyHealth">checkDependencyHealth</a></li><li><a href="global.html#checkRateLimit">checkRateLimit</a></li><li><a href="global.html#checkSystemHealth">checkSystemHealth</a></li><li><a href="global.html#chunk">chunk</a></li><li><a href="global.html#chunkCorpuscles">chunkCorpuscles</a></li><li><a href="global.html#chunkDocument">chunkDocument</a></li><li><a href="global.html#chunkHierarchicalText">chunkHierarchicalText</a></li><li><a href="global.html#chunkText">chunkText</a></li><li><a href="global.html#classifyError">classifyError</a></li><li><a href="global.html#cleanHtml">cleanHtml</a></li><li><a href="global.html#cleanSnippet">cleanSnippet</a></li><li><a href="global.html#cleanup">cleanup</a></li><li><a href="global.html#cleanupPartialInitialization">cleanupPartialInitialization</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#clearCaches">clearCaches</a></li><li><a href="global.html#clearGraph">clearGraph</a></li><li><a href="global.html#clearStatistics">clearStatistics</a></li><li><a href="global.html#clearVectorIndex">clearVectorIndex</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#cluster">cluster</a></li><li><a href="global.html#clusterHypotheticalEntities">clusterHypotheticalEntities</a></li><li><a href="global.html#combineResults">combineResults</a></li><li><a href="global.html#combineSearchResults">combineSearchResults</a></li><li><a href="global.html#combinedResearch">combinedResearch</a></li><li><a href="global.html#compileTrainingResults">compileTrainingResults</a></li><li><a href="global.html#compose">compose</a></li><li><a href="global.html#compress">compress</a></li><li><a href="global.html#compressMetadata">compressMetadata</a></li><li><a href="global.html#computeBetweennessCentrality">computeBetweennessCentrality</a></li><li><a href="global.html#computeCommunityStatistics">computeCommunityStatistics</a></li><li><a href="global.html#computeGraphStatistics">computeGraphStatistics</a></li><li><a href="global.html#computeKCore">computeKCore</a></li><li><a href="global.html#computeLeidenClustering">computeLeidenClustering</a></li><li><a href="global.html#computeSimilarityLinks">computeSimilarityLinks</a></li><li><a href="global.html#conditional">conditional</a></li><li><a href="global.html#connectElements">connectElements</a></li><li><a href="global.html#connectTo">connectTo</a></li><li><a href="global.html#connects">connects</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#convertBuffer">convertBuffer</a></li><li><a href="global.html#convertDocument">convertDocument</a></li><li><a href="global.html#convertEntity">convertEntity</a></li><li><a href="global.html#convertParametersToZPTURIs">convertParametersToZPTURIs</a></li><li><a href="global.html#convertParams">convertParams</a></li><li><a href="global.html#convertString">convertString</a></li><li><a href="global.html#convertToCSV">convertToCSV</a></li><li><a href="global.html#coordinatesToIndex">coordinatesToIndex</a></li><li><a href="global.html#cosineDistance">cosineDistance</a></li><li><a href="global.html#countRules">countRules</a></li><li><a href="global.html#countTokens">countTokens</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAdaptiveChunk">createAdaptiveChunk</a></li><li><a href="global.html#createAttribute">createAttribute</a></li><li><a href="global.html#createAttributeRelationships">createAttributeRelationships</a></li><li><a href="global.html#createBackup">createBackup</a></li><li><a href="global.html#createBatches">createBatches</a></li><li><a href="global.html#createBidirectional">createBidirectional</a></li><li><a href="global.html#createCacheKey">createCacheKey</a></li><li><a href="global.html#createClearGraphQuery">createClearGraphQuery</a></li><li><a href="global.html#createColorScale">createColorScale</a></li><li><a href="global.html#createCompactRepresentation">createCompactRepresentation</a></li><li><a href="global.html#createCompatibilityMappings">createCompatibilityMappings</a></li><li><a href="global.html#createConnector">createConnector</a></li><li><a href="global.html#createCorpuscleForUnit">createCorpuscleForUnit</a></li><li><a href="global.html#createCrossReference">createCrossReference</a></li><li><a href="global.html#createDeleteInsertQuery">createDeleteInsertQuery</a></li><li><a href="global.html#createDirectConceptFilter">createDirectConceptFilter</a></li><li><a href="global.html#createDirectEntityFilter">createDirectEntityFilter</a></li><li><a href="global.html#createDropGraphQuery">createDropGraphQuery</a></li><li><a href="global.html#createEmbeddingConnector">createEmbeddingConnector</a></li><li><a href="global.html#createEmbeddings">createEmbeddings</a></li><li><a href="global.html#createEmptyResult">createEmptyResult</a></li><li><a href="global.html#createEmptyResults">createEmptyResults</a></li><li><a href="global.html#createEntity">createEntity</a></li><li><a href="global.html#createExactTemporalFilter">createExactTemporalFilter</a></li><li><a href="global.html#createExactTopicFilter">createExactTopicFilter</a></li><li><a href="global.html#createHypothesisPrompt">createHypothesisPrompt</a></li><li><a href="global.html#createHypothesisRelationships">createHypothesisRelationships</a></li><li><a href="global.html#createHypothesisUnit">createHypothesisUnit</a></li><li><a href="global.html#createInsertDataQuery">createInsertDataQuery</a></li><li><a href="global.html#createInsertQuery">createInsertQuery</a></li><li><a href="global.html#createInstance">createInstance</a></li><li><a href="global.html#createInterCommunityRelationships">createInterCommunityRelationships</a></li><li><a href="global.html#createLegend">createLegend</a></li><li><a href="global.html#createLiteral">createLiteral</a></li><li><a href="global.html#createNamedNode">createNamedNode</a></li><li><a href="global.html#createNamespace">createNamespace</a></li><li><a href="global.html#createNamespaceObject">createNamespaceObject</a></li><li><a href="global.html#createNeighborhoodFunction">createNeighborhoodFunction</a></li><li><a href="global.html#createOverview">createOverview</a></li><li><a href="global.html#createParameterHash">createParameterHash</a></li><li><a href="global.html#createPointGeographicFilter">createPointGeographicFilter</a></li><li><a href="global.html#createPromptContext">createPromptContext</a></li><li><a href="global.html#createPromptManager">createPromptManager</a></li><li><a href="global.html#createRagnoStructure">createRagnoStructure</a></li><li><a href="global.html#createRelationship">createRelationship</a></li><li><a href="global.html#createResponsiveSVG">createResponsiveSVG</a></li><li><a href="global.html#createSOMInstance">createSOMInstance</a></li><li><a href="global.html#createSemanticChunk">createSemanticChunk</a></li><li><a href="global.html#createTextUnit">createTextUnit</a></li><li><a href="global.html#createTooltip">createTooltip</a></li><li><a href="global.html#createURI">createURI</a></li><li><a href="global.html#createUnit">createUnit</a></li><li><a href="global.html#cubeToOffset">cubeToOffset</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#decomposeCorpus">decomposeCorpus</a></li><li><a href="global.html#decomposeText">decomposeText</a></li><li><a href="global.html#deduplicateByContent">deduplicateByContent</a></li><li><a href="global.html#deduplicateByURI">deduplicateByURI</a></li><li><a href="global.html#deduplicateHybrid">deduplicateHybrid</a></li><li><a href="global.html#deleteDocument">deleteDocument</a></li><li><a href="global.html#deleteInstance">deleteInstance</a></li><li><a href="global.html#detectCommunities">detectCommunities</a></li><li><a href="global.html#detectTboxEnvironment">detectTboxEnvironment</a></li><li><a href="global.html#detectTopicDomain">detectTopicDomain</a></li><li><a href="global.html#determineCorpuscleType">determineCorpuscleType</a></li><li><a href="global.html#determineResponseType">determineResponseType</a></li><li><a href="global.html#displayError">displayError</a></li><li><a href="global.html#displayRecallResults">displayRecallResults</a></li><li><a href="global.html#dispose">dispose</a></li><li><a href="global.html#dropGraph">dropGraph</a></li><li><a href="global.html#dryRun">dryRun</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeStructured">encodeStructured</a></li><li><a href="global.html#enhanceClustersWithCentrality">enhanceClustersWithCentrality</a></li><li><a href="global.html#enhanceNavigation">enhanceNavigation</a></li><li><a href="global.html#enhanceSearchResults">enhanceSearchResults</a></li><li><a href="global.html#enrichGraph">enrichGraph</a></li><li><a href="global.html#enrichWithContext">enrichWithContext</a></li><li><a href="global.html#enrichWithEmbeddings">enrichWithEmbeddings</a></li><li><a href="global.html#ensureInitialized">ensureInitialized</a></li><li><a href="global.html#escapeString">escapeString</a></li><li><a href="global.html#estimateConceptSelectivity">estimateConceptSelectivity</a></li><li><a href="global.html#estimateConfidence">estimateConfidence</a></li><li><a href="global.html#estimateCost">estimateCost</a></li><li><a href="global.html#estimateMemoryUsage">estimateMemoryUsage</a></li><li><a href="global.html#estimateResults">estimateResults</a></li><li><a href="global.html#estimateSegmentSize">estimateSegmentSize</a></li><li><a href="global.html#estimateSelectivity">estimateSelectivity</a></li><li><a href="global.html#estimateTokenCount">estimateTokenCount</a></li><li><a href="global.html#estimateTokensPerResult">estimateTokensPerResult</a></li><li><a href="global.html#estimateTopicSelectivity">estimateTopicSelectivity</a></li><li><a href="global.html#euclideanDistance">euclideanDistance</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#executeNavigationPipeline">executeNavigationPipeline</a></li><li><a href="global.html#executeOperation">executeOperation</a></li><li><a href="global.html#executeQuery">executeQuery</a></li><li><a href="global.html#executeResearch">executeResearch</a></li><li><a href="global.html#executeSPARQLQuery">executeSPARQLQuery</a></li><li><a href="global.html#executeSPARQLUpdate">executeSPARQLUpdate</a></li><li><a href="global.html#executeSelect">executeSelect</a></li><li><a href="global.html#executeSparqlQuery">executeSparqlQuery</a></li><li><a href="global.html#executeStageWithTimeout">executeStageWithTimeout</a></li><li><a href="global.html#executeTemplate">executeTemplate</a></li><li><a href="global.html#executeUpdate">executeUpdate</a></li><li><a href="global.html#executeUpdates">executeUpdates</a></li><li><a href="global.html#executeWithTimeout">executeWithTimeout</a></li><li><a href="global.html#expandCluster">expandCluster</a></li><li><a href="global.html#expandQueryTerms">expandQueryTerms</a></li><li><a href="global.html#exportAllResultsToRDF">exportAllResultsToRDF</a></li><li><a href="global.html#exportCommunitiesToRDF">exportCommunitiesToRDF</a></li><li><a href="global.html#exportEnrichmentResults">exportEnrichmentResults</a></li><li><a href="global.html#exportGraph">exportGraph</a></li><li><a href="global.html#exportResultsToRDF">exportResultsToRDF</a></li><li><a href="global.html#exportToDataset">exportToDataset</a></li><li><a href="global.html#exportToRDF">exportToRDF</a></li><li><a href="global.html#exportVisualization">exportVisualization</a></li><li><a href="global.html#extractAndResearchConcepts">extractAndResearchConcepts</a></li><li><a href="global.html#extractBasicInfo">extractBasicInfo</a></li><li><a href="global.html#extractClientInfo">extractClientInfo</a></li><li><a href="global.html#extractClientIp">extractClientIp</a></li><li><a href="global.html#extractCommunityKeywords">extractCommunityKeywords</a></li><li><a href="global.html#extractConcepts">extractConcepts</a></li><li><a href="global.html#extractContent">extractContent</a></li><li><a href="global.html#extractContentString">extractContentString</a></li><li><a href="global.html#extractCorpuscleConcepts">extractCorpuscleConcepts</a></li><li><a href="global.html#extractEntitiesFromDataset">extractEntitiesFromDataset</a></li><li><a href="global.html#extractEntitiesFromHypothesis">extractEntitiesFromHypothesis</a></li><li><a href="global.html#extractEntitiesFromUnit">extractEntitiesFromUnit</a></li><li><a href="global.html#extractEntityData">extractEntityData</a></li><li><a href="global.html#extractKeywords">extractKeywords</a></li><li><a href="global.html#extractLimit">extractLimit</a></li><li><a href="global.html#extractMetadata">extractMetadata</a></li><li><a href="global.html#extractNamespace">extractNamespace</a></li><li><a href="global.html#extractNavigationMetadata">extractNavigationMetadata</a></li><li><a href="global.html#extractPerformanceMetadata">extractPerformanceMetadata</a></li><li><a href="global.html#extractProvenanceContext">extractProvenanceContext</a></li><li><a href="global.html#extractProvenanceMetadata">extractProvenanceMetadata</a></li><li><a href="global.html#extractQualityMetadata">extractQualityMetadata</a></li><li><a href="global.html#extractRelationshipContext">extractRelationshipContext</a></li><li><a href="global.html#extractScore">extractScore</a></li><li><a href="global.html#extractSourceContext">extractSourceContext</a></li><li><a href="global.html#extractSubgraph">extractSubgraph</a></li><li><a href="global.html#extractTechnicalMetadata">extractTechnicalMetadata</a></li><li><a href="global.html#extractTextContent">extractTextContent</a></li><li><a href="global.html#feedbackTemplates">feedbackTemplates</a></li><li><a href="global.html#fetchWithTimeout">fetchWithTimeout</a></li><li><a href="global.html#filterCorpuscles">filterCorpuscles</a></li><li><a href="global.html#filterSmallCommunities">filterSmallCommunities</a></li><li><a href="global.html#findBestMatchingUnits">findBestMatchingUnits</a></li><li><a href="global.html#findConnectedComponents">findConnectedComponents</a></li><li><a href="global.html#findCrossTypeNodes">findCrossTypeNodes</a></li><li><a href="global.html#findEntitiesByLabel">findEntitiesByLabel</a></li><li><a href="global.html#findEntitiesByWikipediaTitle">findEntitiesByWikipediaTitle</a></li><li><a href="global.html#findEntityCluster">findEntityCluster</a></li><li><a href="global.html#findLazyContent">findLazyContent</a></li><li><a href="global.html#findNextBoundary">findNextBoundary</a></li><li><a href="global.html#findSemanticBoundaries">findSemanticBoundaries</a></li><li><a href="global.html#findSimilarElements">findSimilarElements</a></li><li><a href="global.html#findSimilarNodes">findSimilarNodes</a></li><li><a href="global.html#findSingleBMU">findSingleBMU</a></li><li><a href="global.html#findUnitsWithoutCorpuscles">findUnitsWithoutCorpuscles</a></li><li><a href="global.html#fixedSizeChunking">fixedSizeChunking</a></li><li><a href="global.html#flushSyncQueue">flushSyncQueue</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatAsAnalytical">formatAsAnalytical</a></li><li><a href="global.html#formatAsConversational">formatAsConversational</a></li><li><a href="global.html#formatAsJSON">formatAsJSON</a></li><li><a href="global.html#formatAsMarkdown">formatAsMarkdown</a></li><li><a href="global.html#formatAsStructured">formatAsStructured</a></li><li><a href="global.html#formatContentAsMarkdown">formatContentAsMarkdown</a></li><li><a href="global.html#formatContentNaturally">formatContentNaturally</a></li><li><a href="global.html#formatErrorResponse">formatErrorResponse</a></li><li><a href="global.html#formatGroupSummary">formatGroupSummary</a></li><li><a href="global.html#formatHealthResponse">formatHealthResponse</a></li><li><a href="global.html#formatMetadataAsMarkdown">formatMetadataAsMarkdown</a></li><li><a href="global.html#formatMetricsResponse">formatMetricsResponse</a></li><li><a href="global.html#formatNavigationParameters">formatNavigationParameters</a></li><li><a href="global.html#formatNavigationResponse">formatNavigationResponse</a></li><li><a href="global.html#formatOptionsResponse">formatOptionsResponse</a></li><li><a href="global.html#formatPreviewResponse">formatPreviewResponse</a></li><li><a href="global.html#formatRDFObject">formatRDFObject</a></li><li><a href="global.html#formatSI">formatSI</a></li><li><a href="global.html#formatSchemaResponse">formatSchemaResponse</a></li><li><a href="global.html#formatSingleInteraction">formatSingleInteraction</a></li><li><a href="global.html#formatStructured">formatStructured</a></li><li><a href="global.html#formatSuccessResponse">formatSuccessResponse</a></li><li><a href="global.html#formatTimeAgo">formatTimeAgo</a></li><li><a href="global.html#fromSimpleObject">fromSimpleObject</a></li><li><a href="global.html#gatherCommunityContext">gatherCommunityContext</a></li><li><a href="global.html#gatherEntityContext">gatherEntityContext</a></li><li><a href="global.html#gaussianRandom">gaussianRandom</a></li><li><a href="global.html#generateCacheKey">generateCacheKey</a></li><li><a href="global.html#generateChat">generateChat</a></li><li><a href="global.html#generateChatResponse">generateChatResponse</a></li><li><a href="global.html#generateChatStream">generateChatStream</a></li><li><a href="global.html#generateClusters">generateClusters</a></li><li><a href="global.html#generateCommunitySummary">generateCommunitySummary</a></li><li><a href="global.html#generateCompletion">generateCompletion</a></li><li><a href="global.html#generateConceptURI">generateConceptURI</a></li><li><a href="global.html#generateCorpuscleId">generateCorpuscleId</a></li><li><a href="global.html#generateCorpuscleTriples">generateCorpuscleTriples</a></li><li><a href="global.html#generateEmbedding">generateEmbedding</a></li><li><a href="global.html#generateEntityAttribute">generateEntityAttribute</a></li><li><a href="global.html#generateErrorSuggestions">generateErrorSuggestions</a></li><li><a href="global.html#generateFuzzyPatterns">generateFuzzyPatterns</a></li><li><a href="global.html#generateHypotheses">generateHypotheses</a></li><li><a href="global.html#generateNodeAssignments">generateNodeAssignments</a></li><li><a href="global.html#generateNodeEmbedding">generateNodeEmbedding</a></li><li><a href="global.html#generatePrompt">generatePrompt</a></li><li><a href="global.html#generateQuestions">generateQuestions</a></li><li><a href="global.html#generateReport">generateReport</a></li><li><a href="global.html#generateResponse">generateResponse</a></li><li><a href="global.html#generateResultId">generateResultId</a></li><li><a href="global.html#generateSampleData">generateSampleData</a></li><li><a href="global.html#generateSampleEntities">generateSampleEntities</a></li><li><a href="global.html#generateSingleHypothesis">generateSingleHypothesis</a></li><li><a href="global.html#generateTriplesFromQuads">generateTriplesFromQuads</a></li><li><a href="global.html#generateURI">generateURI</a></li><li><a href="global.html#generateUnitTriples">generateUnitTriples</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAPIRouteHandlers">getAPIRouteHandlers</a></li><li><a href="global.html#getAggregationConfig">getAggregationConfig</a></li><li><a href="global.html#getAggregationFields">getAggregationFields</a></li><li><a href="global.html#getAggregationGroupBy">getAggregationGroupBy</a></li><li><a href="global.html#getAggregationMetrics">getAggregationMetrics</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getAllCustomMetadata">getAllCustomMetadata</a></li><li><a href="global.html#getAllNamespaces">getAllNamespaces</a></li><li><a href="global.html#getAllStatistics">getAllStatistics</a></li><li><a href="global.html#getAllTrainingStatus">getAllTrainingStatus</a></li><li><a href="global.html#getAllTypes">getAllTypes</a></li><li><a href="global.html#getAlternativeNames">getAlternativeNames</a></li><li><a href="global.html#getAttributes">getAttributes</a></li><li><a href="global.html#getAvailableFormats">getAvailableFormats</a></li><li><a href="global.html#getAvailableInstructions">getAvailableInstructions</a></li><li><a href="global.html#getAvailableModels">getAvailableModels</a></li><li><a href="global.html#getAvailableServices">getAvailableServices</a></li><li><a href="global.html#getAvailableStrategies">getAvailableStrategies</a></li><li><a href="global.html#getAvailableTemplates">getAvailableTemplates</a></li><li><a href="global.html#getAvailableTokenizers">getAvailableTokenizers</a></li><li><a href="global.html#getBaseFields">getBaseFields</a></li><li><a href="global.html#getCacheKey">getCacheKey</a></li><li><a href="global.html#getCacheStats">getCacheStats</a></li><li><a href="global.html#getCachedResult">getCachedResult</a></li><li><a href="global.html#getCategory">getCategory</a></li><li><a href="global.html#getClusters">getClusters</a></li><li><a href="global.html#getCommunities">getCommunities</a></li><li><a href="global.html#getConfidence">getConfidence</a></li><li><a href="global.html#getConnectedElements">getConnectedElements</a></li><li><a href="global.html#getConnectedUnits">getConnectedUnits</a></li><li><a href="global.html#getContent">getContent</a></li><li><a href="global.html#getContextRecommendation">getContextRecommendation</a></li><li><a href="global.html#getContextTruncationLimit">getContextTruncationLimit</a></li><li><a href="global.html#getCorpus">getCorpus</a></li><li><a href="global.html#getCorpuscleType">getCorpuscleType</a></li><li><a href="global.html#getDefaultConfig">getDefaultConfig</a></li><li><a href="global.html#getDefaultFieldMappings">getDefaultFieldMappings</a></li><li><a href="global.html#getDefaultTiltURI">getDefaultTiltURI</a></li><li><a href="global.html#getDefaultWeights">getDefaultWeights</a></li><li><a href="global.html#getDefaultZoomURI">getDefaultZoomURI</a></li><li><a href="global.html#getDefaults">getDefaults</a></li><li><a href="global.html#getDocument">getDocument</a></li><li><a href="global.html#getEmbedding">getEmbedding</a></li><li><a href="global.html#getEndpointInfo">getEndpointInfo</a></li><li><a href="global.html#getEndpoints">getEndpoints</a></li><li><a href="global.html#getEnhancedEntityContext">getEnhancedEntityContext</a></li><li><a href="global.html#getEntities">getEntities</a></li><li><a href="global.html#getEntity">getEntity</a></li><li><a href="global.html#getEntityProperties">getEntityProperties</a></li><li><a href="global.html#getEntityRelationships">getEntityRelationships</a></li><li><a href="global.html#getErrorStats">getErrorStats</a></li><li><a href="global.html#getEvidence">getEvidence</a></li><li><a href="global.html#getExecutionStats">getExecutionStats</a></li><li><a href="global.html#getFeatureMaps">getFeatureMaps</a></li><li><a href="global.html#getFilterDocumentation">getFilterDocumentation</a></li><li><a href="global.html#getFirstSeen">getFirstSeen</a></li><li><a href="global.html#getFormatInfo">getFormatInfo</a></li><li><a href="global.html#getFrequency">getFrequency</a></li><li><a href="global.html#getGraphStatistics">getGraphStatistics</a></li><li><a href="global.html#getGraphStats">getGraphStats</a></li><li><a href="global.html#getGridState">getGridState</a></li><li><a href="global.html#getHealth">getHealth</a></li><li><a href="global.html#getHexagonalVisualCoords">getHexagonalVisualCoords</a></li><li><a href="global.html#getInfo">getInfo</a></li><li><a href="global.html#getInstanceHierarchy">getInstanceHierarchy</a></li><li><a href="global.html#getInstructionInfo">getInstructionInfo</a></li><li><a href="global.html#getJSONLDContext">getJSONLDContext</a></li><li><a href="global.html#getKeywords">getKeywords</a></li><li><a href="global.html#getLanguage">getLanguage</a></li><li><a href="global.html#getLastAccessed">getLastAccessed</a></li><li><a href="global.html#getLegacyAdapter">getLegacyAdapter</a></li><li><a href="global.html#getLength">getLength</a></li><li><a href="global.html#getMentionedEntities">getMentionedEntities</a></li><li><a href="global.html#getMetadata">getMetadata</a></li><li><a href="global.html#getMetadataProperty">getMetadataProperty</a></li><li><a href="global.html#getMetrics">getMetrics</a></li><li><a href="global.html#getModelConfig">getModelConfig</a></li><li><a href="global.html#getModelInfo">getModelInfo</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getNamespace">getNamespace</a></li><li><a href="global.html#getNavigationStatistics">getNavigationStatistics</a></li><li><a href="global.html#getNeighbors">getNeighbors</a></li><li><a href="global.html#getNodeMappings">getNodeMappings</a></li><li><a href="global.html#getNodeMetadata">getNodeMetadata</a></li><li><a href="global.html#getNodeType">getNodeType</a></li><li><a href="global.html#getNodeWeights">getNodeWeights</a></li><li><a href="global.html#getNodesByType">getNodesByType</a></li><li><a href="global.html#getOntologyInfo">getOntologyInfo</a></li><li><a href="global.html#getOntologyTerms">getOntologyTerms</a></li><li><a href="global.html#getOptimalResultLimit">getOptimalResultLimit</a></li><li><a href="global.html#getOptions">getOptions</a></li><li><a href="global.html#getOtherEntity">getOtherEntity</a></li><li><a href="global.html#getPPRScore">getPPRScore</a></li><li><a href="global.html#getParameterSummary">getParameterSummary</a></li><li><a href="global.html#getParserInfo">getParserInfo</a></li><li><a href="global.html#getPerformanceStats">getPerformanceStats</a></li><li><a href="global.html#getPosition">getPosition</a></li><li><a href="global.html#getPrefLabel">getPrefLabel</a></li><li><a href="global.html#getPreferredLabel">getPreferredLabel</a></li><li><a href="global.html#getPrefixes">getPrefixes</a></li><li><a href="global.html#getPrefixesAsObject">getPrefixesAsObject</a></li><li><a href="global.html#getPrimaryTypes">getPrimaryTypes</a></li><li><a href="global.html#getProcessingStatus">getProcessingStatus</a></li><li><a href="global.html#getProjectionDocumentation">getProjectionDocumentation</a></li><li><a href="global.html#getPromptManager">getPromptManager</a></li><li><a href="global.html#getProvenance">getProvenance</a></li><li><a href="global.html#getQuery">getQuery</a></li><li><a href="global.html#getQueryStats">getQueryStats</a></li><li><a href="global.html#getQuestionStatistics">getQuestionStatistics</a></li><li><a href="global.html#getQuestionsForResearch">getQuestionsForResearch</a></li><li><a href="global.html#getRagnoLocalName">getRagnoLocalName</a></li><li><a href="global.html#getRecommendations">getRecommendations</a></li><li><a href="global.html#getRecommendedTilt">getRecommendedTilt</a></li><li><a href="global.html#getRelationshipType">getRelationshipType</a></li><li><a href="global.html#getRelationships">getRelationships</a></li><li><a href="global.html#getRouteHandlers">getRouteHandlers</a></li><li><a href="global.html#getRuleSelectivity">getRuleSelectivity</a></li><li><a href="global.html#getSPARQLPrefixes">getSPARQLPrefixes</a></li><li><a href="global.html#getSchema">getSchema</a></li><li><a href="global.html#getSearchStrategies">getSearchStrategies</a></li><li><a href="global.html#getSelectionStrategy">getSelectionStrategy</a></li><li><a href="global.html#getSession">getSession</a></li><li><a href="global.html#getSessions">getSessions</a></li><li><a href="global.html#getSimilarityScore">getSimilarityScore</a></li><li><a href="global.html#getSourceDocument">getSourceDocument</a></li><li><a href="global.html#getSourceEntity">getSourceEntity</a></li><li><a href="global.html#getStatistics">getStatistics</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#getStatus">getStatus</a></li><li><a href="global.html#getStrategyInfo">getStrategyInfo</a></li><li><a href="global.html#getSubType">getSubType</a></li><li><a href="global.html#getSummary">getSummary</a></li><li><a href="global.html#getSupportedExtensions">getSupportedExtensions</a></li><li><a href="global.html#getSupportedProviders">getSupportedProviders</a></li><li><a href="global.html#getTargetEntity">getTargetEntity</a></li><li><a href="global.html#getTargetTypes">getTargetTypes</a></li><li><a href="global.html#getTemplate">getTemplate</a></li><li><a href="global.html#getTemplateMetadata">getTemplateMetadata</a></li><li><a href="global.html#getTemporal">getTemporal</a></li><li><a href="global.html#getText">getText</a></li><li><a href="global.html#getTiltFields">getTiltFields</a></li><li><a href="global.html#getTiltOutputFormat">getTiltOutputFormat</a></li><li><a href="global.html#getTiltProcessingType">getTiltProcessingType</a></li><li><a href="global.html#getTokenizerInfo">getTokenizerInfo</a></li><li><a href="global.html#getTopKNodes">getTopKNodes</a></li><li><a href="global.html#getTopology">getTopology</a></li><li><a href="global.html#getTopologyInfo">getTopologyInfo</a></li><li><a href="global.html#getTrainingStatus">getTrainingStatus</a></li><li><a href="global.html#getTriples">getTriples</a></li><li><a href="global.html#getTriplesWithPredicate">getTriplesWithPredicate</a></li><li><a href="global.html#getTurtlePrefixes">getTurtlePrefixes</a></li><li><a href="global.html#getTypes">getTypes</a></li><li><a href="global.html#getURI">getURI</a></li><li><a href="global.html#getUnits">getUnits</a></li><li><a href="global.html#getView">getView</a></li><li><a href="global.html#getViews">getViews</a></li><li><a href="global.html#getVisualizationCoordinates">getVisualizationCoordinates</a></li><li><a href="global.html#getWeight">getWeight</a></li><li><a href="global.html#getWikidataNamespaces">getWikidataNamespaces</a></li><li><a href="global.html#getWikidataProperties">getWikidataProperties</a></li><li><a href="global.html#getZoomDescriptions">getZoomDescriptions</a></li><li><a href="global.html#getZoomGranularity">getZoomGranularity</a></li><li><a href="global.html#getZoomLevelDocumentation">getZoomLevelDocumentation</a></li><li><a href="global.html#getZoomMapping">getZoomMapping</a></li><li><a href="global.html#groupNodesByType">groupNodesByType</a></li><li><a href="global.html#handleDomainSwitch">handleDomainSwitch</a></li><li><a href="global.html#handleDualSearch">handleDualSearch</a></li><li><a href="global.html#handleEntityDetails">handleEntityDetails</a></li><li><a href="global.html#handleError">handleError</a></li><li><a href="global.html#handleExactSearch">handleExactSearch</a></li><li><a href="global.html#handleFadeMemory">handleFadeMemory</a></li><li><a href="global.html#handleForget">handleForget</a></li><li><a href="global.html#handleGraphStats">handleGraphStats</a></li><li><a href="global.html#handleHealth">handleHealth</a></li><li><a href="global.html#handleMemoryFilter">handleMemoryFilter</a></li><li><a href="global.html#handleMetrics">handleMetrics</a></li><li><a href="global.html#handleNavigate">handleNavigate</a></li><li><a href="global.html#handleOptions">handleOptions</a></li><li><a href="global.html#handlePreview">handlePreview</a></li><li><a href="global.html#handleProjectContext">handleProjectContext</a></li><li><a href="global.html#handleRecall">handleRecall</a></li><li><a href="global.html#handleRemember">handleRemember</a></li><li><a href="global.html#handleRequest">handleRequest</a></li><li><a href="global.html#handleSchema">handleSchema</a></li><li><a href="global.html#handleSearchStats">handleSearchStats</a></li><li><a href="global.html#handleSearchStatus">handleSearchStatus</a></li><li><a href="global.html#handleSimilaritySearch">handleSimilaritySearch</a></li><li><a href="global.html#handleTraversalSearch">handleTraversalSearch</a></li><li><a href="global.html#hasFilters">hasFilters</a></li><li><a href="global.html#hasNode">hasNode</a></li><li><a href="global.html#hasRelationshipWith">hasRelationshipWith</a></li><li><a href="global.html#hasStructure">hasStructure</a></li><li><a href="global.html#hasType">hasType</a></li><li><a href="global.html#hashObject">hashObject</a></li><li><a href="global.html#healthCheck">healthCheck</a></li><li><a href="global.html#hierarchicalChunking">hierarchicalChunking</a></li><li><a href="global.html#highlightQuery">highlightQuery</a></li><li><a href="global.html#identifyImportantEntities">identifyImportantEntities</a></li><li><a href="global.html#identifyRetrievableNodes">identifyRetrievableNodes</a></li><li><a href="global.html#incrementFrequency">incrementFrequency</a></li><li><a href="global.html#indexContent">indexContent</a></li><li><a href="global.html#indexToCoordinates">indexToCoordinates</a></li><li><a href="global.html#ingest">ingest</a></li><li><a href="global.html#ingestDocument">ingestDocument</a></li><li><a href="global.html#ingestFromTemplate">ingestFromTemplate</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initChatForms">initChatForms</a></li><li><a href="global.html#initMCPClient">initMCPClient</a></li><li><a href="global.html#initRangeInputs">initRangeInputs</a></li><li><a href="global.html#initSettingsForm">initSettingsForm</a></li><li><a href="global.html#initTabs">initTabs</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeApp">initializeApp</a></li><li><a href="global.html#initializeAtuin">initializeAtuin</a></li><li><a href="global.html#initializeBoundaryDetectors">initializeBoundaryDetectors</a></li><li><a href="global.html#initializeChunkingStrategies">initializeChunkingStrategies</a></li><li><a href="global.html#initializeCompressionLevels">initializeCompressionLevels</a></li><li><a href="global.html#initializeConfig">initializeConfig</a></li><li><a href="global.html#initializeDefaultRules">initializeDefaultRules</a></li><li><a href="global.html#initializeDefaults">initializeDefaults</a></li><li><a href="global.html#initializeDocumentProcessing">initializeDocumentProcessing</a></li><li><a href="global.html#initializeDomainPatterns">initializeDomainPatterns</a></li><li><a href="global.html#initializeEmbeddingHandler">initializeEmbeddingHandler</a></li><li><a href="global.html#initializeEncodingStrategies">initializeEncodingStrategies</a></li><li><a href="global.html#initializeEndpoints">initializeEndpoints</a></li><li><a href="global.html#initializeErrorCodes">initializeErrorCodes</a></li><li><a href="global.html#initializeErrorTypes">initializeErrorTypes</a></li><li><a href="global.html#initializeFallbackConceptTemplates">initializeFallbackConceptTemplates</a></li><li><a href="global.html#initializeFilterStrategies">initializeFilterStrategies</a></li><li><a href="global.html#initializeFormats">initializeFormats</a></li><li><a href="global.html#initializeFormatters">initializeFormatters</a></li><li><a href="global.html#initializeInstructions">initializeInstructions</a></li><li><a href="global.html#initializeLLMHandler">initializeLLMHandler</a></li><li><a href="global.html#initializeLegacyAdapters">initializeLegacyAdapters</a></li><li><a href="global.html#initializeLinearWeights">initializeLinearWeights</a></li><li><a href="global.html#initializeMemoryDomains">initializeMemoryDomains</a></li><li><a href="global.html#initializeMetadataSchemas">initializeMetadataSchemas</a></li><li><a href="global.html#initializeModelMappings">initializeModelMappings</a></li><li><a href="global.html#initializeNamespaces">initializeNamespaces</a></li><li><a href="global.html#initializeOutputFormats">initializeOutputFormats</a></li><li><a href="global.html#initializePCAWeights">initializePCAWeights</a></li><li><a href="global.html#initializePipeline">initializePipeline</a></li><li><a href="global.html#initializeProjectionStrategies">initializeProjectionStrategies</a></li><li><a href="global.html#initializePromptSystem">initializePromptSystem</a></li><li><a href="global.html#initializeQueryTemplates">initializeQueryTemplates</a></li><li><a href="global.html#initializeRandomWeights">initializeRandomWeights</a></li><li><a href="global.html#initializeRecoveryStrategies">initializeRecoveryStrategies</a></li><li><a href="global.html#initializeSPARQLServices">initializeSPARQLServices</a></li><li><a href="global.html#initializeSchemas">initializeSchemas</a></li><li><a href="global.html#initializeSelectionStrategies">initializeSelectionStrategies</a></li><li><a href="global.html#initializeTemplates">initializeTemplates</a></li><li><a href="global.html#initializeTokenizers">initializeTokenizers</a></li><li><a href="global.html#initializeValidators">initializeValidators</a></li><li><a href="global.html#initializeWeights">initializeWeights</a></li><li><a href="global.html#initializeZoomMappings">initializeZoomMappings</a></li><li><a href="global.html#integrateWithGraphAnalytics">integrateWithGraphAnalytics</a></li><li><a href="global.html#integrateWithHyde">integrateWithHyde</a></li><li><a href="global.html#involves">involves</a></li><li><a href="global.html#isAvailable">isAvailable</a></li><li><a href="global.html#isCode">isCode</a></li><li><a href="global.html#isEntryPoint">isEntryPoint</a></li><li><a href="global.html#isProviderSupported">isProviderSupported</a></li><li><a href="global.html#isRagnoClass">isRagnoClass</a></li><li><a href="global.html#isRagnoProperty">isRagnoProperty</a></li><li><a href="global.html#isRagnoURI">isRagnoURI</a></li><li><a href="global.html#isRelevantAt">isRelevantAt</a></li><li><a href="global.html#isStopWord">isStopWord</a></li><li><a href="global.html#isSupported">isSupported</a></li><li><a href="global.html#isTboxFusekiAvailable">isTboxFusekiAvailable</a></li><li><a href="global.html#isValidCoordinate">isValidCoordinate</a></li><li><a href="global.html#legacyFormatChatPrompt">legacyFormatChatPrompt</a></li><li><a href="global.html#limitResults">limitResults</a></li><li><a href="global.html#listDocuments">listDocuments</a></li><li><a href="global.html#listExternalTemplateFiles">listExternalTemplateFiles</a></li><li><a href="global.html#listInstances">listInstances</a></li><li><a href="global.html#listTemplates">listTemplates</a></li><li><a href="global.html#loadChatProviders">loadChatProviders</a></li><li><a href="global.html#loadConceptQueries">loadConceptQueries</a></li><li><a href="global.html#loadConfigFromServer">loadConfigFromServer</a></li><li><a href="global.html#loadData">loadData</a></li><li><a href="global.html#loadDocQAData">loadDocQAData</a></li><li><a href="global.html#loadEnvironmentVariables">loadEnvironmentVariables</a></li><li><a href="global.html#loadExternalTemplate">loadExternalTemplate</a></li><li><a href="global.html#loadExternalTemplates">loadExternalTemplates</a></li><li><a href="global.html#loadFromEntities">loadFromEntities</a></li><li><a href="global.html#loadFromRagno">loadFromRagno</a></li><li><a href="global.html#loadFromSPARQL">loadFromSPARQL</a></li><li><a href="global.html#loadFromVectorIndex">loadFromVectorIndex</a></li><li><a href="global.html#loadIndex">loadIndex</a></li><li><a href="global.html#loadMemoryState">loadMemoryState</a></li><li><a href="global.html#loadSettings">loadSettings</a></li><li><a href="global.html#loadTemplate">loadTemplate</a></li><li><a href="global.html#loadTemplatesFromPromptTemplates">loadTemplatesFromPromptTemplates</a></li><li><a href="global.html#loadUnitsToSPARQL">loadUnitsToSPARQL</a></li><li><a href="global.html#loadVectorIndex">loadVectorIndex</a></li><li><a href="global.html#localMovingPhase">localMovingPhase</a></li><li><a href="global.html#logProcessingSummary">logProcessingSummary</a></li><li><a href="global.html#logTrainingProgress">logTrainingProgress</a></li><li><a href="global.html#lookupEntity">lookupEntity</a></li><li><a href="global.html#manhattanDistance">manhattanDistance</a></li><li><a href="global.html#markQuestionResearched">markQuestionResearched</a></li><li><a href="global.html#matchEndpoint">matchEndpoint</a></li><li><a href="global.html#matchesFilters">matchesFilters</a></li><li><a href="global.html#memorize">memorize</a></li><li><a href="global.html#mergeSmallChunks">mergeSmallChunks</a></li><li><a href="global.html#migrate">migrate</a></li><li><a href="global.html#migrateDocument">migrateDocument</a></li><li><a href="global.html#migrateDocuments">migrateDocuments</a></li><li><a href="global.html#migrateExistingSystem">migrateExistingSystem</a></li><li><a href="global.html#migrateMCPRegistry">migrateMCPRegistry</a></li><li><a href="global.html#migrateNavigation">migrateNavigation</a></li><li><a href="global.html#migratePromptTemplates">migratePromptTemplates</a></li><li><a href="global.html#navigate">navigate</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#normalizeContent">normalizeContent</a></li><li><a href="global.html#normalizeCoordinates">normalizeCoordinates</a></li><li><a href="global.html#normalizeEntityFilter">normalizeEntityFilter</a></li><li><a href="global.html#normalizeError">normalizeError</a></li><li><a href="global.html#normalizeGeographicFilter">normalizeGeographicFilter</a></li><li><a href="global.html#normalizeMinMax">normalizeMinMax</a></li><li><a href="global.html#normalizePan">normalizePan</a></li><li><a href="global.html#normalizePath">normalizePath</a></li><li><a href="global.html#normalizeScoreArray">normalizeScoreArray</a></li><li><a href="global.html#normalizeScores">normalizeScores</a></li><li><a href="global.html#normalizeSigmoid">normalizeSigmoid</a></li><li><a href="global.html#normalizeTemplate">normalizeTemplate</a></li><li><a href="global.html#normalizeTemporalFilter">normalizeTemporalFilter</a></li><li><a href="global.html#normalizeTilt">normalizeTilt</a></li><li><a href="global.html#normalizeTopicFilter">normalizeTopicFilter</a></li><li><a href="global.html#normalizeTransform">normalizeTransform</a></li><li><a href="global.html#normalizeZScore">normalizeZScore</a></li><li><a href="global.html#normalizeZoom">normalizeZoom</a></li><li><a href="global.html#offsetToCube">offsetToCube</a></li><li><a href="global.html#optimizeCriteria">optimizeCriteria</a></li><li><a href="global.html#optimizeIndex">optimizeIndex</a></li><li><a href="global.html#optimizeTokenUsage">optimizeTokenUsage</a></li><li><a href="global.html#optimizeVectorIndex">optimizeVectorIndex</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseBody">parseBody</a></li><li><a href="global.html#parseComponents">parseComponents</a></li><li><a href="global.html#parseCookies">parseCookies</a></li><li><a href="global.html#parseEntityExtractionResponse">parseEntityExtractionResponse</a></li><li><a href="global.html#parseFormBody">parseFormBody</a></li><li><a href="global.html#parseHeaders">parseHeaders</a></li><li><a href="global.html#parseJsonBody">parseJsonBody</a></li><li><a href="global.html#parseJsonResponse">parseJsonResponse</a></li><li><a href="global.html#parseMultipartBody">parseMultipartBody</a></li><li><a href="global.html#parseMultipartPart">parseMultipartPart</a></li><li><a href="global.html#parseQueryParams">parseQueryParams</a></li><li><a href="global.html#parseQueryResults">parseQueryResults</a></li><li><a href="global.html#performClustering">performClustering</a></li><li><a href="global.html#performExactMatch">performExactMatch</a></li><li><a href="global.html#performHealthCheck">performHealthCheck</a></li><li><a href="global.html#performPPRTraversal">performPPRTraversal</a></li><li><a href="global.html#performQuickRecall">performQuickRecall</a></li><li><a href="global.html#performVectorSimilarity">performVectorSimilarity</a></li><li><a href="global.html#populateSettingsFromConfig">populateSettingsFromConfig</a></li><li><a href="global.html#populateVectorIndexFromSPARQL">populateVectorIndexFromSPARQL</a></li><li><a href="global.html#postProcessChunks">postProcessChunks</a></li><li><a href="global.html#postProcessCorpuscles">postProcessCorpuscles</a></li><li><a href="global.html#preciseTokenCount">preciseTokenCount</a></li><li><a href="global.html#preloadTemplates">preloadTemplates</a></li><li><a href="global.html#preview">preview</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processBatch">processBatch</a></li><li><a href="global.html#processConcepts">processConcepts</a></li><li><a href="global.html#processEntityData">processEntityData</a></li><li><a href="global.html#processIterations">processIterations</a></li><li><a href="global.html#processQuery">processQuery</a></li><li><a href="global.html#processRelationships">processRelationships</a></li><li><a href="global.html#processResults">processResults</a></li><li><a href="global.html#processSPARQLResults">processSPARQLResults</a></li><li><a href="global.html#processSparqlData">processSparqlData</a></li><li><a href="global.html#processUnitsInBatches">processUnitsInBatches</a></li><li><a href="global.html#project">project</a></li><li><a href="global.html#projectToConcepts">projectToConcepts</a></li><li><a href="global.html#projectToEmbedding">projectToEmbedding</a></li><li><a href="global.html#projectToGraph">projectToGraph</a></li><li><a href="global.html#projectToKeywords">projectToKeywords</a></li><li><a href="global.html#projectToTemporal">projectToTemporal</a></li><li><a href="global.html#pruneContext">pruneContext</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#queryByZoomLevel">queryByZoomLevel</a></li><li><a href="global.html#queryConceptsByFilter">queryConceptsByFilter</a></li><li><a href="global.html#queryCorpuscles">queryCorpuscles</a></li><li><a href="global.html#queryDocumentChunks">queryDocumentChunks</a></li><li><a href="global.html#queryDocuments">queryDocuments</a></li><li><a href="global.html#queryHypotheses">queryHypotheses</a></li><li><a href="global.html#queryHypotheticalContent">queryHypotheticalContent</a></li><li><a href="global.html#queryUnits">queryUnits</a></li><li><a href="global.html#queueSync">queueSync</a></li><li><a href="global.html#quickStart">quickStart</a></li><li><a href="global.html#rankByScore">rankByScore</a></li><li><a href="global.html#rankBySimilarity">rankBySimilarity</a></li><li><a href="global.html#rankByType">rankByType</a></li><li><a href="global.html#rankByWeightedScore">rankByWeightedScore</a></li><li><a href="global.html#rankHybrid">rankHybrid</a></li><li><a href="global.html#readRawBody">readRawBody</a></li><li><a href="global.html#recordIteration">recordIteration</a></li><li><a href="global.html#recoverFromValidationError">recoverFromValidationError</a></li><li><a href="global.html#recursive">recursive</a></li><li><a href="global.html#refinementPhase">refinementPhase</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#registerBatch">registerBatch</a></li><li><a href="global.html#registerTemplate">registerTemplate</a></li><li><a href="global.html#reloadExternalTemplates">reloadExternalTemplates</a></li><li><a href="global.html#removeNamespace">removeNamespace</a></li><li><a href="global.html#removeNode">removeNode</a></li><li><a href="global.html#removeNodeFromIndex">removeNodeFromIndex</a></li><li><a href="global.html#removeTriple">removeTriple</a></li><li><a href="global.html#researchConcepts">researchConcepts</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetStatistics">resetStatistics</a></li><li><a href="global.html#resetStats">resetStats</a></li><li><a href="global.html#resolve">resolve</a></li><li><a href="global.html#resolveEntityNamesToURIs">resolveEntityNamesToURIs</a></li><li><a href="global.html#resolveSyntax">resolveSyntax</a></li><li><a href="global.html#restoreFromBackup">restoreFromBackup</a></li><li><a href="global.html#retrieveInteractions">retrieveInteractions</a></li><li><a href="global.html#runDeepPPR">runDeepPPR</a></li><li><a href="global.html#runEntityClustering">runEntityClustering</a></li><li><a href="global.html#runFullAnalysis">runFullAnalysis</a></li><li><a href="global.html#runFullMigration">runFullMigration</a></li><li><a href="global.html#runFullPipeline">runFullPipeline</a></li><li><a href="global.html#runHydeGeneration">runHydeGeneration</a></li><li><a href="global.html#runPPR">runPPR</a></li><li><a href="global.html#runSemanticSearch">runSemanticSearch</a></li><li><a href="global.html#runShallowPPR">runShallowPPR</a></li><li><a href="global.html#runTargetedAnalysis">runTargetedAnalysis</a></li><li><a href="global.html#runVSOMAnalysis">runVSOMAnalysis</a></li><li><a href="global.html#sanitizeData">sanitizeData</a></li><li><a href="global.html#sanitizeErrorMessage">sanitizeErrorMessage</a></li><li><a href="global.html#saveIndex">saveIndex</a></li><li><a href="global.html#saveVectorIndex">saveVectorIndex</a></li><li><a href="global.html#scoreByGraph">scoreByGraph</a></li><li><a href="global.html#scoreByKeywords">scoreByKeywords</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#searchByConcepts">searchByConcepts</a></li><li><a href="global.html#searchByText">searchByText</a></li><li><a href="global.html#searchByTypes">searchByTypes</a></li><li><a href="global.html#searchByWikipediaTitle">searchByWikipediaTitle</a></li><li><a href="global.html#searchContent">searchContent</a></li><li><a href="global.html#searchExact">searchExact</a></li><li><a href="global.html#searchGraph">searchGraph</a></li><li><a href="global.html#searchSimilarity">searchSimilarity</a></li><li><a href="global.html#searchTraversal">searchTraversal</a></li><li><a href="global.html#searchWikipedia">searchWikipedia</a></li><li><a href="global.html#seededRandom">seededRandom</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#selectByEmbedding">selectByEmbedding</a></li><li><a href="global.html#selectByGraph">selectByGraph</a></li><li><a href="global.html#selectByKeywords">selectByKeywords</a></li><li><a href="global.html#selectByTemporal">selectByTemporal</a></li><li><a href="global.html#selectEnhanced">selectEnhanced</a></li><li><a href="global.html#selectOptimalStrategy">selectOptimalStrategy</a></li><li><a href="global.html#semanticChunking">semanticChunking</a></li><li><a href="global.html#sendError">sendError</a></li><li><a href="global.html#sendSuccess">sendSuccess</a></li><li><a href="global.html#setAllMetadata">setAllMetadata</a></li><li><a href="global.html#setCategory">setCategory</a></li><li><a href="global.html#setConfidence">setConfidence</a></li><li><a href="global.html#setContent">setContent</a></li><li><a href="global.html#setCorpus">setCorpus</a></li><li><a href="global.html#setEmbedding">setEmbedding</a></li><li><a href="global.html#setEmbeddingHandler">setEmbeddingHandler</a></li><li><a href="global.html#setEntity">setEntity</a></li><li><a href="global.html#setEntryPoint">setEntryPoint</a></li><li><a href="global.html#setFirstSeen">setFirstSeen</a></li><li><a href="global.html#setFrequency">setFrequency</a></li><li><a href="global.html#setLLMHandler">setLLMHandler</a></li><li><a href="global.html#setLanguage">setLanguage</a></li><li><a href="global.html#setLastAccessed">setLastAccessed</a></li><li><a href="global.html#setLength">setLength</a></li><li><a href="global.html#setMetadataProperty">setMetadataProperty</a></li><li><a href="global.html#setName">setName</a></li><li><a href="global.html#setNodeWeights">setNodeWeights</a></li><li><a href="global.html#setPPRScore">setPPRScore</a></li><li><a href="global.html#setPosition">setPosition</a></li><li><a href="global.html#setPrefLabel">setPrefLabel</a></li><li><a href="global.html#setProvenance">setProvenance</a></li><li><a href="global.html#setRelationshipType">setRelationshipType</a></li><li><a href="global.html#setSPARQLEndpoint">setSPARQLEndpoint</a></li><li><a href="global.html#setSimilarityScore">setSimilarityScore</a></li><li><a href="global.html#setSourceDocument">setSourceDocument</a></li><li><a href="global.html#setSourceEntity">setSourceEntity</a></li><li><a href="global.html#setSubType">setSubType</a></li><li><a href="global.html#setSummary">setSummary</a></li><li><a href="global.html#setTargetEntity">setTargetEntity</a></li><li><a href="global.html#setTemperature">setTemperature</a></li><li><a href="global.html#setTemporal">setTemporal</a></li><li><a href="global.html#setText">setText</a></li><li><a href="global.html#setVectorIndex">setVectorIndex</a></li><li><a href="global.html#setWeight">setWeight</a></li><li><a href="global.html#setupDebug">setupDebug</a></li><li><a href="global.html#setupErrorHandling">setupErrorHandling</a></li><li><a href="global.html#setupEventListeners">setupEventListeners</a></li><li><a href="global.html#setupFailsafeTimeout">setupFailsafeTimeout</a></li><li><a href="global.html#setupQuickActions">setupQuickActions</a></li><li><a href="global.html#showLoading">showLoading</a></li><li><a href="global.html#shuffleArray">shuffleArray</a></li><li><a href="global.html#shutdown">shutdown</a></li><li><a href="global.html#shutdownAll">shutdownAll</a></li><li><a href="global.html#simpleHash">simpleHash</a></li><li><a href="global.html#splitLargeSection">splitLargeSection</a></li><li><a href="global.html#stopAllTraining">stopAllTraining</a></li><li><a href="global.html#stopTraining">stopTraining</a></li><li><a href="global.html#store">store</a></li><li><a href="global.html#storeCommunity">storeCommunity</a></li><li><a href="global.html#storeConceptRelationships">storeConceptRelationships</a></li><li><a href="global.html#storeConcepts">storeConcepts</a></li><li><a href="global.html#storeDocument">storeDocument</a></li><li><a href="global.html#storeEmbeddingInRDF">storeEmbeddingInRDF</a></li><li><a href="global.html#storeEntity">storeEntity</a></li><li><a href="global.html#storeInteraction">storeInteraction</a></li><li><a href="global.html#storeLazyContent">storeLazyContent</a></li><li><a href="global.html#storeNavigationData">storeNavigationData</a></li><li><a href="global.html#storeRelationship">storeRelationship</a></li><li><a href="global.html#storeSemanticUnit">storeSemanticUnit</a></li><li><a href="global.html#storeSession">storeSession</a></li><li><a href="global.html#storeZPTDataInSPARQL">storeZPTDataInSPARQL</a></li><li><a href="global.html#streamChatResponse">streamChatResponse</a></li><li><a href="global.html#summarizeContext">summarizeContext</a></li><li><a href="global.html#summarizeFilters">summarizeFilters</a></li><li><a href="global.html#supportsTilt">supportsTilt</a></li><li><a href="global.html#switchToProject">switchToProject</a></li><li><a href="global.html#timeOperation">timeOperation</a></li><li><a href="global.html#toNTriples">toNTriples</a></li><li><a href="global.html#toSimpleObject">toSimpleObject</a></li><li><a href="global.html#toTurtle">toTurtle</a></li><li><a href="global.html#tokenAwareChunking">tokenAwareChunking</a></li><li><a href="global.html#toroidalDistance">toroidalDistance</a></li><li><a href="global.html#touch">touch</a></li><li><a href="global.html#trackActiveRequest">trackActiveRequest</a></li><li><a href="global.html#train">train</a></li><li><a href="global.html#trainSOM">trainSOM</a></li><li><a href="global.html#trainingStep">trainingStep</a></li><li><a href="global.html#transform">transform</a></li><li><a href="global.html#transformDocQAToVSOM">transformDocQAToVSOM</a></li><li><a href="global.html#transformToCorpuscles">transformToCorpuscles</a></li><li><a href="global.html#transformToDocument">transformToDocument</a></li><li><a href="global.html#transformToUnits">transformToUnits</a></li><li><a href="global.html#traverseGraph">traverseGraph</a></li><li><a href="global.html#unifiedSearch">unifiedSearch</a></li><li><a href="global.html#unregister">unregister</a></li><li><a href="global.html#updateConfig">updateConfig</a></li><li><a href="global.html#updateDomainDisplay">updateDomainDisplay</a></li><li><a href="global.html#updateGraph">updateGraph</a></li><li><a href="global.html#updateLazyToProcessed">updateLazyToProcessed</a></li><li><a href="global.html#updateMemoryDisplay">updateMemoryDisplay</a></li><li><a href="global.html#updateMemoryStats">updateMemoryStats</a></li><li><a href="global.html#updateMetrics">updateMetrics</a></li><li><a href="global.html#updateModified">updateModified</a></li><li><a href="global.html#updateProjectDisplay">updateProjectDisplay</a></li><li><a href="global.html#updateRequestStats">updateRequestStats</a></li><li><a href="global.html#updateSearchStatistics">updateSearchStatistics</a></li><li><a href="global.html#updateUI">updateUI</a></li><li><a href="global.html#updateWeights">updateWeights</a></li><li><a href="global.html#uploadDocument">uploadDocument</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateCompatibility">validateCompatibility</a></li><li><a href="global.html#validateConfig">validateConfig</a></li><li><a href="global.html#validateConfiguration">validateConfiguration</a></li><li><a href="global.html#validateContentType">validateContentType</a></li><li><a href="global.html#validateCorpus">validateCorpus</a></li><li><a href="global.html#validateCriteria">validateCriteria</a></li><li><a href="global.html#validateDependencies">validateDependencies</a></li><li><a href="global.html#validateGeographic">validateGeographic</a></li><li><a href="global.html#validateInput">validateInput</a></li><li><a href="global.html#validateJsonStructure">validateJsonStructure</a></li><li><a href="global.html#validateMetadata">validateMetadata</a></li><li><a href="global.html#validateMigration">validateMigration</a></li><li><a href="global.html#validateModel">validateModel</a></li><li><a href="global.html#validateNormalized">validateNormalized</a></li><li><a href="global.html#validateOntology">validateOntology</a></li><li><a href="global.html#validateOptions">validateOptions</a></li><li><a href="global.html#validatePan">validatePan</a></li><li><a href="global.html#validateQuery">validateQuery</a></li><li><a href="global.html#validateRagnoURI">validateRagnoURI</a></li><li><a href="global.html#validateRequest">validateRequest</a></li><li><a href="global.html#validateSearchRequest">validateSearchRequest</a></li><li><a href="global.html#validateTemporal">validateTemporal</a></li><li><a href="global.html#validateTilt">validateTilt</a></li><li><a href="global.html#validateTransform">validateTransform</a></li><li><a href="global.html#validateZoom">validateZoom</a></li><li><a href="global.html#verifyComponentsReady">verifyComponentsReady</a></li><li><a href="global.html#withRateLimit">withRateLimit</a></li><li><a href="global.html#withTiming">withTiming</a></li><li><a href="global.html#zptDataFactory">zptDataFactory</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Sep 07 2025 14:33:02 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
